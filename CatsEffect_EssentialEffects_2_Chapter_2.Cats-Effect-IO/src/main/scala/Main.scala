


import cats.effect.{ExitCode, IO, IOApp}
import cats.effect.unsafe.implicits.global
import cats.implicits._

import scala.concurrent.Future
import scala.concurrent.duration.DurationInt
import scala.language.postfixOps



object Main1 extends App {
  println("Изучаем Cats Effect - книга Essential Effects")

  // https://github.com/inner-product/essential-effects-code

  // В этой книге мы покажем изменения в коде в виде “различий”, которые вы можете увидеть в обзоре кода.
  // Исходный код отображается красным цветом с префиксом -,
  // а обновленная версия - зеленым цветом с префиксом +.

  object part1 {
    def chapter2 = {
      // Chapter 2. Cats Effect IO

      // Мы создали свой собственный тип эффекта MyIO, чтобы понять, как отсрочить побочные эффекты,
      // сохраняя при этом возможность создавать новые модели поведения, используя такие методы, как map и flatMap.
      // Теперь мы представим эффект cats.effect.IO, который обладает теми же свойствами,
      // и кратко опишите типичные способы создания, преобразования и выполнения значений ввода-вывода.
      // Мы также покажем, как создавать приложения с использованием эффектов с помощью cats.effect.IOApp

      // Построение значений IO
      // Чаще всего мы используем IO.delay, чтобы захватить побочный эффект в качестве значения IO:

      /*
            def delay[A](a: => A): IO[A]
      */

      // IO.delay принимает аргумент call-by-name (лениво вычисляемый), задерживая вычисление кода:

      val hw: IO[Unit] = IO.delay(println("Hello world!"))
      println {
        hw.unsafeRunSync()
      }

      //Отложите вычисление этого выражения, чтобы при его (более позднем) выполнении оно
      //выводило Hello world на консоль и выдавало значение ().

      // IO.apply - это псевдоним для IO.delay. Это позволяет нам писать IO(...) вместо IO.delay(...), что короче:

      val hw1: IO[Unit] = IO.delay(println("Hello world 1!"))
      val hw2: IO[Unit] = IO(println("Hello world 2!"))

      println(hw1.unsafeRunSync(), hw2.unsafeRunSync())

      // Когда эффект выполняется, что произойдет, если побочный эффект вызовет исключение?
      // Например, что произойдет, если вы создадите значение ввода-вывода, подобное этому?

      val ohNoes: IO[Int] = IO.delay(throw new RuntimeException("oh noes!"))

      // Мы знаем, что, несмотря на то, что этот эффект имеет тип IO[Int], он не может генерировать значение Int
      //  из-за throw. Однако побочный эффект throw откладывается до тех пор, пока не будет
      // выполнен IO, и тогда и только тогда он вызовет исключение.

      // Хотя это менее распространено, мы также можем создавать значения ввода-вывода
      // из существующих “чистых” значений:

      val twelve: IO[Int] = IO.pure(12)

      println {
        twelve.unsafeRunSync()
      }

      // Будь осторожен! Не выполняйте никаких побочных эффектов при вызове IO.pure, потому что они будут
      // немедленно выполнены, и это нарушит подстановку. Если вы не уверены, используйте
      // IO.delay или IO.apply на всякий случай.

      // Мы также можем “поднять” исключение в IO, если мы укажем “ожидаемый” тип IO,
      // как если бы он был успешным, либо явно, либо путем вывода типа:

      val ohNoes2: IO[Int] = IO.raiseError(new RuntimeException("oh noes!"))

      // Обратите внимание на разницу между использованием IO.RaiseError и предыдущим упражнением,
      // которое вызывало исключение при вызове IO.задержка. Здесь у нас уже есть
      // исключение в качестве значения.

      // Поскольку это распространенный альтернативный тип эффекта, существует общий способ преобразования
      // scala.concurrent.Future значений в значения IO:

      def futurish: Future[String] = Future.successful("Hi!")

      val fut: IO[String] = IO.fromFuture(IO(futurish))

      println {
        fut.unsafeRunSync()
      }

      // Мы преобразуем Future в IO, но должны передать Future внутри IO. Как вы думаете, почему это так?
      // Чтобы Future не выполнилось немедленно.

      // Преобразование значений IO

      // Как только у нас появятся значения IO, мы можем вызывать различные методы для получения новых значений IO.
      // Эти методы часто называют комбинаторами.

      // IO - это функтор; мы можем map его:

      val io1: IO[Int] = IO(12).map(_ + 1)

      println{
        io1.unsafeRunSync()
      }
      // When executed, produces 13

      // IO - это аппликативный функтор; мы можем map два или более значения:

      val io2: IO[String] = (IO(12), IO("hi")).mapN((i, s) => s"$s: $i")

      println{
        io2.unsafeRunSync()
      }
      // When executed, produces "hi: 12"

      // IO - это монада; мы можем flatMap на ней или, что более удобно, мы можем использовать for-comprehension

      val io3: IO[String] = for {
        i <- IO(12)
        j <- IO(i + 1)
      } yield j.toString

      println{
        io3.unsafeRunSync()
      }
      // When executed, produces "13"

      // Существует множество других комбинаторов.
      // В The Appendix A, Cheat sheets, приведены наиболее распространенные из них.

      // Обработка ошибок

      // Как мы уже видели, вычисление IO может завершиться неудачей либо из-за возникновения исключения во
      //  время выполнения, либо из-за перехвата существующего исключения с помощью IO.RaiseError.
      //  Однако мы можем обнаружить эти сбои и что-то с этим сделать.
      //  Обычные комбигаторы для обработки ошибок используют HandleErrorWith,
      //  который имеет сигнатуру, аналогичную flatMap, за исключением того, что он принимает значения ошибок:

      /*
            def handleErrorWith[AA >: A](f: Throwable => IO[AA]): IO[AA]
      */

      // Мы исправляем ошибку, создавая новый эффект:

      val ohNoes3: IO[Int] = IO.raiseError[Int](new RuntimeException("oh noes!"))
      val handled: IO[Int] = ohNoes3.handleErrorWith(_ => IO(12))

      println{
        handled.unsafeRunSync()
      }

      // Если вы хотите просто указать успешное значение, вы можете использовать HandleError:

      val h1 =  ohNoes.handleErrorWith(_ => IO(12))
      val h2 =  ohNoes.handleError(_ => 12)

      // Но handleErrorWith не обязательно должен давать успешный эффект, он может привести
      // к эффекту, который сам по себе сбойный:

      val handled2: IO[Int] =
        ohNoes.handleErrorWith(t => IO.raiseError(new RuntimeException(t)))

      // Если мы явно хотим преобразовать ошибку в другую ошибку, мы могли бы вместо этого использовать adaptError:

      val h3 = ohNoes.handleErrorWith(t => IO.raiseError(new RuntimeException(t)))
      val h4 = ohNoes.adaptError(t => new RuntimeException(t))

      // Эти комбинаторы скрывают логику обработки ошибок от кода, который использует эти эффекты:
      // например, метод может возвращать IO[Int], который мог быть вызван handleErrorWith.
      // Есть интересная альтернатива этому, где мы вместо этого обрабатываем ошибки,
      // преобразуя их в любое из значений, таким образом,
      // IO[A] теперь становится IO[Either[Throwable, A]]

      /*
            def attempt(): IO[Either[Throwable, A]]
      */

      // Вместо того, чтобы скрывать обработку ошибок, мы теперь раскрываем ошибку, но также
      // откладываем обработку ошибок, “переводя” ошибку в (успешное) значение IO:

      /*
              val attempted: IO[Either[Throwable, Int]] =
                - ohNoes
                -    .map(i => Right(i): Either[Throwable, Int])
                -    .handleErrorWith(t => Left(t))
                + ohNoes.attempt
      */


     /*
            Дерево решений по обработке ошибок

            Если в вашем IO[A] возникает ошибка, что вы хотите сделать?..

            ----- обработка с сохранением сбойности производимого эффекта ----

            хотим просто выполнить побочный эффект при сбое?
            Используйте
            onError(pf: PartialFunction[Throwable, IO[Unit]]): IO[A].

            преобразовать любую ошибку в другую ошибку?
            Используйте
            adaptError(pf: PartialFunction[Throwable, Throwable]): IO[A].

            ----- восстановление - преобразование в другой успешный/неуспешный эффект ----

            преобразуйте любую ошибку в успешное значение?
            Используйте
            handleError(f: Throwable => A): IO[A].

            преобразовать некоторые виды ошибок в успешное значение?
            Используйте
            recover(pf: PartialFunction[Throwable, A]): IO[A].

            преобразовать некоторые виды ошибок в другой эффект?
            Используйте
            recoverWith(pf: PartialFunction[Throwable, IO[A]]): IO[A].

            делают ошибки видимыми, но задерживают обработку ошибок?
            Используйте
            attempt: IO[Either[Throwable, A]].

            В противном случае используйте
            handleErrorWith(f: Throwable => IO[A]): IO[A].

      */

      // Выполнение значений IO

      // Мы отложили все побочные эффекты, инкапсулировав их в значение IO.
      // Когда мы закончим составлять нашу программу, мы, наконец, запустим эффекты.
      // Существует несколько способов их выполнения, и все они имеют префикс unsafe, обозначающий, что
      // будут выполнены Побочный эффект и что наш процесс замены больше не применяется.
      // Распространенным небезопасным методом, с которым вы столкнетесь, является unsafeRunSync.
      // Run означает выполнение, а sync - синхронное выполнение; вместе они запускают эффекты
      // синхронно и возвращают результат.
      // Вызов unsafeRunSync для IO[A] приведет к созданию значение типа A, если эффект будет успешным:

      /*
              def unsafeRunSync: A
      */

      println{
        IO("hello world!").unsafeRunSync()
        // produces the value "hello world!"
      }

      // Если эффект генерирует исключение во время выполнения или если он был создан непосредственно
      // с помощью IO.RaiseError, то это исключение будет сгенерировано из unsafeRunSync.
      // Естественно, существует unsafeRunAsync и другие методы, но они используются реже.
      // Однако более распространенным является метод unsafeToFuture, который вы
      // можете использовать для интеграции вашего эффективного кода с устаревшими интерфейсами,
      // которые могут использовать scala.concurrent.Future:

      /*
           def unsafeToFuture: Future[A]
      */

      // Но опять же, будьте осторожны! Как правило, вы не должны вызывать в своем коде какие-либо небезопасные методы.
      // Экспериментируя с REPL или каким-либо другим одноразовым кодом, будьте уверены.
      // В противном случае не делайте этого!
      // Вместо этого вы передадите эту ответственность таким типам, как IOApp, о которых рассказывается ниже.
      // Но сначала мы проверим, действует ли cats.effect.IO - это эффект или нет.

      // IO как эффект

      // Давайте оценим IO в соответствии с нашим контрольным списком шаблонов эффектов.

      // Контрольный список шаблонов эффектов: IO[A]
      // 1. Указывает ли тип программы на:
      //     a. какие эффекты будет выполнять программа;
      //      Ввод-вывод представляет собой (возможно) побочное вычисление.
      //     b. какой тип значения это даст?
      //      Значение типа A, если вычисление завершилось успешно.
      // 2. Когда требуются побочные эффекты, видимые извне, описание эффекта
      // должно быть отделено от выполнения?
      //     Требуются побочные эффекты, видимые извне: при выполнении IO может быть что угодно,
      //    включая побочные эффекты.
      //     Мы описываем значения ввода-вывода с помощью различных конструкторов и описываем
      //    комбинируйте эффекты, составляя их с помощью таких методов, как map, mapN, flatMap и т.д.
      //    Эффект выполняется только при вызове  unsafe* метода.
      //  Следовательно, IO - это эффект!

      // Посмотрите прикольную картинку, демонстрирующую безопасное отложенное выполнение эффекта IO
      // resources/IO.png


      // Выполнение эффектов в приложениях с помощью IOApp

      // Как мы интегрируем эффекты в наши приложения? Мы снова будем использовать наш шаблон эффектов:
      // Учитывая наличие побочных эффектов, отделим описание нашей программы от ее выполнения.

      // Затем наши приложения будут отражать эту структуру:
      //  1. Мы описываем эффекты, которые хотим получить;
      //  2. Приложение выполняет их, когда мы его запускаем.

      // Для этого Cats Effect предоставляет тип IOApp для приложений.
      // IOApp — это исполняемый файл типа Scala, имеющий метод main, который требует,
      // чтобы вы объявляли свои эффекты как одно значение IO, и он выполняет задачу по выполнению этих эффектов.

      // Посмотрите ниже и запустите приложение HelloWorldApp

      // Абстрактный метод run приложения ввода-вывода требует, чтобы вы возвращали значение IO.
      // Как IOApp  выполняет эффекты? Поскольку IO выполняется только при вызове небезопасного метода,
      // такого как unsafeRunSync, IOApp должен вызвать его для нас.
      // В результате работы нашего приложения создается код завершения, перечисление, которое абстрагируется от
      // кода завершения ОС, чтобы вернуть его в операционную систему после завершения работы приложения.
      // Большинство приложений вернет ExitCode.Success, но вы всегда можете вернуть ExitCode.Error,
      // или создайте код выхода с числовым значением, где ненулевые значения означают ошибку.

      // Давайте немного потренируемся в создании IOApp: мы создадим тикающие часы.
      // Посмотрите ниже и запустите приложение TickingClock

      // В дальнейшем мы перейдем к использованию IOApp в примерах и упражнениях.

      // Резюме.

      // 1. cats.effect.IO - это эффект, который может инкапсулировать любой побочный эффект.
      //     a. Конструкторы создают IO из чистых значений, отложенных побочных эффектов, ошибок
      //     и других типов, таких как Future.
      //     b. Комбинаторы позволяют создавать новые эффекты, преобразовывать их выходные данные и обрабатывать ошибки.
      //     Важно, чтобы каждый комбинатор избегал выполнения какого-либо эффекта, иначе замена будет нарушена.
      //     c. Мы можем выполнять IO[A] значения, которые выдают либо значение типа A, либо вызывают исключение.
      //     Вам следует запускать их только на самых “краях” ваших программ с помощью методов с unsafe префиксом.
      //2. cats.effect.IOApp позволяет описать ваше приложение как отдельный эффект IO, который оно выполняет.

    }
  }

  part1.chapter2


}


object HelloWorldApp extends IOApp {

  // 1 Ваше приложение должно быть объектом и должно расширять IOApp.
  // 2 Точкой входа в приложение является метод run, который должен возвращать значение IO[ExitCode].
  // 3 Укажите вычисления, которые будут выполняться.

  override def run(args: List[String]): IO[ExitCode] = helloWorld.as(ExitCode.Success)

  val helloWorld: IO[Unit] = IO(println("Hello world from APP!"))
}



object TickingClock extends IOApp {

  // 1 Сначала мы выводим текущее время с помощью System.currentTimeMillis, затем
  // 2 переходим в режим ожидания на одну секунду, а затем
  // 3 используем рекурсию, чтобы повторить это.

  override def run(args: List[String]): IO[ExitCode] = tickingClock.as(ExitCode.Success)

  val tickingClock: IO[Unit] =
    for {
      _ <- IO(println(System.currentTimeMillis))
      _ <- IO.sleep(1 second)
      _ <- tickingClock
    } yield ()
}

