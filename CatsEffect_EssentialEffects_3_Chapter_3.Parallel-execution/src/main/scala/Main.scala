


import cats.effect.IO
import cats.effect.unsafe.implicits.global

import scala.language.postfixOps
import cats.implicits._

import scala.concurrent._
import scala.concurrent.duration._


object Main1 extends App {
  println("Изучаем Cats Effect - книга Essential Effects")

  // https://github.com/inner-product/essential-effects-code

  // В этой книге мы покажем изменения в коде в виде “различий”, которые вы можете увидеть в обзоре кода.
  // Исходный код отображается красным цветом с префиксом -,
  // а обновленная версия - зеленым цветом с префиксом +.

  object part1 {
    def chapter3 = {
      // Chapter 3. Parallel execution

      // Захват побочных эффектов в качестве составного типа данных ввода-вывода полезен сам по себе, но как только мы
      // это сделаем, мы сможем продвинуться дальше. Если у нас есть несколько значений ввода-вывода, которые не зависят друг
      // от друга, не должны ли мы иметь возможность запускать их параллельно? Таким образом, наши
      // вычисления в целом могут стать более эффективными.
      // Сначала мы обсудим, поддерживает ли сам IO параллелизм или нет. Затем мы поговорим о том, как
      // IO может поддерживать параллелизм и как этот параллелизм реализуется. Затем мы
      // рассмотрим несколько примеров различных способов параллельного создания значений ввода-вывода.

      // 3.1 Поддерживает ли IO параллелизм?

      // Чтобы ответить на вопрос о том, поддерживает ли IO параллелизм, давайте сначала
      // сравним его с аналогичным типом данных scala.concurrent.Future, который, как мы видели, поддерживает
      // параллелизм , планируя работу в нескольких потоках с помощью
      // scala.concurrent.ExecutionContext.

      //Давайте композируем несколько Future, используя как flatMap (с помощью for-comprehension), так и map.
      // В приведенном ниже коде эффект hw1 такой же, как и эффект hw2?
      // Работают ли hello и world параллельно или нет? Какие выходные данные мы увидим на консоли?

      implicit val ec = ExecutionContext.global

      val hello = Future{
        println(s"[${Thread.currentThread.getName}] Hello")
        Thread.sleep(10)
      }
      val world = Future{
        println(s"[${Thread.currentThread.getName}] World")
        Thread.sleep(10)
      }

      val hw1: Future[Unit] = for {
        _ <- hello
        _ <- world
      } yield ()

      val res1 = Await.ready(hw1, 5 seconds)

      val hw2: Future[Unit] = (hello, world).mapN((_, _) => ())
      val res2 = Await.ready(hw2, 5 seconds)

      // Мы добавили некоторый вспомогательный код, чтобы показать текущий поток во время
      // выполнения Future.

      // Эффект hw1 такой же, как...
      //.. эффект hw2?

      // Если мы запустим эту программу, то увидим следующий результат
      // (ваши идентификаторы потоков могут отличаться).:

      // [scala-execution-context-global-21] Hello
      // [scala-execution-context-global-22] World

      // Мы видим только одну пару напечатанных надписей "Привет" и "Мир". Почему?
      // Потому что Future автоматически планирует действие и кэширует результат.
      // Это нарушает правило № 2 нашего эффекта
      // Шаблон: небезопасный побочный эффект не выполняется отдельно от функций, подобных конструктору Future.
      // Прости! Мы сочли необходимым напомнить вам, что Future с готовностью применяет побочные эффекты.

      println("-----------------")

      // Давайте постараемся отсрочить побочные эффекты как можно дольше:

      def helloF = Future{
        println(s"[${Thread.currentThread.getName}] Hello")
        Thread.sleep(10)
      }
      def worldF = Future{
        println(s"[${Thread.currentThread.getName}] World")
        Thread.sleep(10)
      }
      val hw1F: Future[Unit] = for {
          _ <- helloF
          _ <- worldF
      } yield ()

      val res1F = Await.ready(hw1, 5 seconds)

      val hw2F: Future[Unit] = (helloF, worldF).mapN((_, _) => ())
      val res2F = Await.ready(hw2, 5.seconds)

      // Обратите внимание, что мы заменили значение val на значение def, чтобы избежать кэширования в режиме Future из предыдущего примера.

      // Является ли эффект hw1 таким же, как...

      //... эффект hw2?

      // Если мы запустим эту программу, то увидим следующий результат:

        // [scala-execution-context-global-21] Hello
        // [scala-execution-context-global-23] Hello
        // [scala-execution-context-global-22] World
        // [scala-execution-context-global-33] World

      // Теперь вывод — корректный — показывает нам две пары выходных данных Hello и World.
      // И мы видим, что вторая пара выходных данных от вызова map выполняется в разных потоках.
      // Но будьте осторожны! Даже если мы видим, что вывод выполняется в двух разных потоках,
      // это не означает, что эти вычисления выполнялись параллельно.
      // Как вы могли бы показать, выполнялись они параллельно или нет? (Не так уж важно отвечать на этот вопрос).
      // В то же время, вычисление hw2 на самом деле недетерминировано, поэтому вы также можете
      // увидеть Hello, напечатанный перед World. Что делает выходные данные недетерминированными?

      // В то время как эффекты hw2 недетерминированы, мы можем сказать одно о
      // выполнении hw1, вычислении, которое использует for-comprehension.
      // Поскольку функция for-comprehension является синтаксическим дополнением для серии вложенных вызовов flatMap,
      // мы можем с уверенностью сказать, что эффект world всегда будет выполняться после эффекта hello,
      // поскольку эффект world создается (и впоследствии выполняется) только после вычисления значения
      // hello:

      /*
              val hw1: Future[Unit] =
              - for {
              -    _ <- hello
              -    _ <- world
              - } yield ()
              + hello.flatMap { _ =>
              +   world.map { _ =>
              +     ()
              +   }
              + }
      */

      // Синтаксический сахар for-comprehension - это серия вложенных вызовов flatMap.
      // Как только мы разберем синтаксис, мы увидим, что world выполняется только после
      // вычисления результата hello, потому что результат hello передается функции, заданной для
      // flatMap.

      // С другой стороны, мы можем сделать вывод, что hw2, использующий map, будет запускать hello и
      // world параллельно. Почему это так?
      // Если мы немного проанализируем определение hw2, то сможем увидеть ,
      // что происходит нечто важное:

     /*
           val hw2: Future[Unit] =
              (
            -   hello,
            +   Future(println(s"[${Thread.currentThread.getName}] Hello")) 1
            -   world
            +   Future(println(s"[${Thread.currentThread.getName}] World")) 2
              ).mapN((_, _) => ())
     */

      // Мы знаем, что когда мы создаем Future, оно становится запланированным.
      // Второе Future также запланировано, так что теперь оба будут выполняться независимо.

      // Это демонстрирует, что для Future flatMap и map имеют разные эффекты в отношении параллелизма.
      // Но обратите внимание: это не тот случай, когда mapN для Future реализован с использованием параллелизма,
      // а flatMap реализован как нечто последовательное.
      // Параллелизм возникает как побочный эффект — каламбур — от того, что Future с готовностью планирует вычисления,
      // которые происходят до того, как будет вычислена сама map.

      println("---------------")

      // Что насчет IO? Имеет ли использование map и flatMap другой эффект, как это делает Future?

      val helloIO = IO(println(s"[${Thread.currentThread.getName}] Hello"))
      val worldIO = IO(println(s"[${Thread.currentThread.getName}] World"))

      val hw1IO: IO[Unit] = for {
          _ <- helloIO
          _ <- worldIO
        } yield ()

      val hw2IO: IO[Unit] = (helloIO, worldIO).mapN((_, _) => ())

      hw1IO.unsafeRunSync()
      hw2IO.unsafeRunSync()

      // Мы используем код, эквивалентный предыдущим примерам, с Future, чтобы
      // обеспечить максимальную согласованность.

      // Является ли эффект hw1 таким же, как...

      //... эффект hw2?

      // вывод программы
        // [io-compute-2] Hello
        // [io-compute-2] World
        // [io-compute-0] Hello
        // [io-compute-0] World

      // Теперь мы видим ожидаемый результат, но все потоки одинаковы. Ожидали ли вы этого?
      // Считаете ли вы, что hw2 имеет недетерминированный результат, как в предыдущем примере с использованием Future?
      // IO не обеспечивает никакой поддержки эффекта параллелизма! И это сделано специально,
      // потому что мы хотим, чтобы разные эффекты имели разные типы в соответствии с нашим шаблоном эффектов.

      // 3.2. The Parallel typeclass

      // Как мы уже видели, в отличие от Future, IO сам по себе не поддерживает параллелизм.
      // Итак, как мы можем этого добиться?
      // Мы снова будем следовать нашему шаблону эффектов и применим правило № 1: тип должен отражать эффект.
      // Если IO не поддерживает параллелизм, нам нужен новый тип, который поддерживает.
      // В cats.effect этот тип называется IO.Par (Par означает “параллельный”).

      /*
              sealed abstract class IO[+A] { ... } 1

              object IO {
                class Par[+A] { ... } 2

                object Par {
                  def apply[A](ioa: IO[A]): Par[A] = ??? 3
                  def unwrap[A](pa: Par[A]): IO[A] = ??? 3
                }
              }
      */

      // 1 Тип данных (последовательного) IO
      // 2 Тип данных параллельного  IO, IO.Par
      // 3 Методы преобразования между IO и IO.Par значениями

      // IO.Par не является экземпляром Monad, потому что мы не хотим, чтобы можно было сериализовать последовательно
      // выполнение нескольких действий. Вместо этого у него будет экземпляр Applicative для
      // создания независимого IO.Par значения

      /*
            implicit def ap(implicit cs: ContextShift[IO]): Applicative[IO.Par] = 1
              new Applicative[IO.Par] {
                def pure[A](a: A): IO.Par[A] = IO.Par(IO.pure(a))
                def map[A, B](pa: IO.Par[A])(f: A => B): IO.Par[B] = ???
                def product[A, B](pa: IO.Par[A], pb: IO.Par[B]): IO.Par[(A, B)] = ??? 2
              }
      */

      // 1 Нам требуется Context Shift[IO], чтобы иметь возможность переключать вычисления в разные потоки.
      // Мы подробнее поговорим о ContextShift в главе 5 "Изменение контекстов", но пока вы можете думать
      // о нем как о чем-то подобном scala.concurrent.ExecutionContext или пуле потоков.
      // 2 Реализация product обеспечит выполнение pa и pb в разных потоках с использованием cs.

      // Необходимость переключать типы при переводе между последовательным и параллельным выполнением
      // является несколько многословной. Это выглядело бы так:

      /*
            val ia: IO[A] = IO(???)
            val ib: IO[B] = IO(???)

            def f(a: A, b: B): C = ???

            val ipa: IO.Par[A] = IO.Par(ia) 1
            val ipb: IO.Par[B] = IO.Par(ib) 1

            val ipc: IO.Par[C] = (ipa, ipb).mapN(f) 2

            val ic: IO[C] = IO.Par.unwrap(ipc) 3
      */

      // Parallel класс типов из библиотеки Cats (не Cats Effect) отражает концепцию преобразования между
      // двумя связанными типами данных:

      /*
              trait Parallel[S[_]] {    1
                type P[_]      2

                def monad: Monad[S]      3

                def applicative: Applicative[P]      4

                def sequential: P ~> S     5

                def parallel: S ~> P       5
              }
      */

      // 1 Экземпляры Typeclass относятся к типам S (для последовательных).
      // Например, будет существовать экземпляр typeclass Parallel[IO], где IO - это
      // преобразуемый последовательный тип.
      // 2 Экземпляр Typeclass определяет тип P (для параллельных). Для параллельного экземпляра Parallel[IO]
      //  typeclass, P будет IO.Par.
      // 3 S должны содержать монаду. То есть операции с использованием S должны быть упорядочены.
      // 4 P должны иметь значение Applicative. То есть операции, использующие P, не должны иметь каких
      //  -либо зависимостей от порядка данных.
      // 5 Параллельный экземпляр должен быть способен преобразовывать последовательные значения в параллельные и обратно.

      // Символ ~> является псевдонимом типа для cats.arrow.FunctionK, которая представляет собой
      // преобразование из некоторого типа F[A] в другой тип G[A] для любого типа A.
      // Таким образом, тип P ~> S эквивалентен коду типа
      // def apply[A](pa: P[A]): S[A].

      // Диаграмма: Parallel typeclass кодирует преобразования между последовательным типом S и параллельным типом P.
      // resources/Parallel_typeclass.png

      //Переписываем трансляцию между IO и IO.Par в терминах Parallel, который теперь у нас есть:


    }
  }

  part1.chapter3


}

