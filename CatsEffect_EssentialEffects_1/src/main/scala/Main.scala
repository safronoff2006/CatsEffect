

import cats.{Functor, Monad}

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.duration.{DurationInt, FiniteDuration}
import scala.concurrent.{Await, Future}
import scala.language.postfixOps
import cats.implicits._

import java.util.concurrent.TimeUnit
import scala.util.Try


object Main1 extends App {
  println("Изучаем Cats Effect - книга Essential Effects")

  // https://github.com/inner-product/essential-effects-code

  // В этой книге мы покажем изменения в коде в виде “различий”, которые вы можете увидеть в обзоре кода.
  // Исходный код отображается красным цветом с префиксом -,
  // а обновленная версия - зеленым цветом с префиксом +.

  object part1 {
    def preface = {

      println()
      println("====================================== Preface")

      // Предпосылки
      // Essential Effects основана на общем наборе методов функционального программирования:
      //  функторы, аппликативы и монады. Если какие-либо из них вам не знакомы, пожалуйста, ознакомьтесь с ними ниже.
      //  Возможно, вы не знакомы с самими техническими терминами, но, возможно
      //, вы уже знакомы с концепциями и использовали их в своих проектах.

      // Более глубокое погружение в основы функционального программирования можно найти в книгах
      // Essential Scala
      // https://underscore.io/books/essential-scala/

      // Scala with Cats.
      // https://scalawithcats.com/


      // Functors

      // Функтор отражает понятие чего-либо, что вы можете сопоставить, изменяя его
      // “содержимое” (или выходные данные), но не саму структуру.
      // Многие типы позволяют вам сопоставлять их.
      // Например, все эти типы являются функторами:


      val list = List(1, 2, 3).map(_ + 1)
      val opt = Option(1).map(_ + 1)
      val future = Future(1).map(_ + 1)

      println(list)
      println(opt)
      println{
        Await.result(future, 5 seconds)
      }

      // Сигнатура map для некоторого значения типа F[A], где типом F может быть List, Option и т.д.,
      // выглядит следующим образом:

      // def map[B](f: A => B): F[B]

      // В Essential Effects мы будем использовать map довольно часто.
      // Помимо map, мы также будем использовать методы расширения as и void из Functor:

      val fa: Functor[Option] = Functor[Option]

      val replaced1: Option[String] = fa.map(Some(3))(_ => "replacement")
      val replaced2: Option[String] = fa.as(Some(3),"replacement")

      val voided1: Option[Unit] = fa.map(Some(3))(_ => ())
      val voided2 = fa.void(Some(3))

      println(replaced1, replaced2)
      println(voided1, voided2)

      println("------------------------------")

      // Applicatives

      // Аппликативный функтор, также известный как applicative,
      // это функтор, который может преобразовывать несколько структур, а не только одну.
      // Давайте начнем наш пример с того, что сначала применим map к одному
      // значению параметра (это функтор) и расширим его, чтобы продемонстрировать прикладной
      // метод mapN, действующий на кортежи значений:

      val o1: Option[Int] = Option(1).map(_ + 1)
      val o2: Option[Int] = (Option(1), Option(2)).mapN(_ + _ + 1)
      val o3: Option[Int] =  (Option(1), Option(2), Option(3)).mapN(_ + _ + _ + 1)

      // В более общем плане, для некоторого прикладного типа с именем F[_]
      // мы можем составить кортеж значений F в одно значение F, используя map:

      /*
            def map[B](A => B): F[B]
            def mapN[C]((A,B) => C): F[C]
            def mapN[D]((A,B,C) => D): F[D]

            def mapN[Z]((A, ...) => Z): F[Z]
      */

      // В Essential Effects мы будем использовать аппликативные методы для создания нескольких
      // независимых эффектов, например, при параллельных вычислениях.
      // В частности, мы часто будем использовать символьный аппликативный метод *> для создания двух
      // эффектов, но отбрасывать результат первого. Это эквивалентно следующему вызову mapN:

      val first1 = Option("Один")
      val second1 = Option(1)

      val third1_1: Option[Int] = (first1, second1).mapN((_, b) => b)
      val third1_2: Option[Int] = first1 *> second1

      println(third1_1, third1_2)

      // Метод *> включает в себя два эффекта, первый и второй, с помощью map.
      // Если оба эффекта успешны, мы игнорируем значение первого эффекта,
      // возвращая только значение второго эффекта.

      val first2 = Option.empty[String]
      val second2 = Option(1)
      val third2 =  first2 *> second2

      println {
        third2
      }

      val first3 = Option.empty[String]
      val second3 = Option.empty[Int]
      val third3 =  first3 *> second3

      println {
        third3
      }

      println("------------------------------")

      // Monads

      // Монада - это механизм для упорядочивания вычислений: это выполнение вычисления после этого вычисления.
      // Грубо говоря, монада предоставляет метод flatMap для значения F[A]:

      // def flatMap[B](f: A => F[B]): F[B]

      // Мы можем использовать flatMap некоторой монады F[_] для упорядочивания вычислений:

      def next(a: Int): Option[Int] = Try(10/a).toOption

      val ma1  = Some(5)
      val mb1: Option[Int] = ma1.flatMap(next)
      println(ma1, mb1)

      val ma2  = Some(0)
      val mb2: Option[Int] = ma2.flatMap(next)
      println(ma2, mb2)

      val ma3  = Option.empty[Int]
      val mb3: Option[Int] = ma3.flatMap(next)
      println(ma3, mb3)

      // Производит новое вычисление F[B] на основе (чистого) значения.

      // Поскольку вложенные вызовы flatMap могут усложняться для чтения, когда нам нужно выполнить более двух вычислений,
      // мы можем использовать вместо этого for-comprehension.
      // Это просто синтаксический сахар для вложенных вызовов flatMap:

      def nextB(a: Int): Option[Int] = Try(10/a).toOption
      def nextC(b: Int): Option[String] = Some(b.toString)

      val maa = Option(2)

      val mc1: Option[String] = maa.flatMap{
        a => nextB(a).flatMap{ b =>
          nextC(b)
        }
      }

      val mc2: Option[String] = for {
        a <- maa
        b <- nextB(a)
        c <- nextC(b)
      } yield c

      println(mc1, mc2)


    }

    def chapter1 = {
      println()
      println("====================================== Chapter 1")

      // Эффекты: вычисление и выполнение

      /*

      Мы часто используем термин "эффект", когда говорим о поведении нашего кода, например
      “Каков результат этой операции?” или, при отладке, “Выполнение этого не
      должно иметь эффекта, что происходит?”, где “что происходит?”, скорее
      всего, заменяется ругательством. Но что такое эффект? Можем ли мы точно описать эффекты,
      чтобы писать более совершенные программы, которые мы могли бы лучше понять?
      Чтобы изучить, что такое эффекты и как мы можем их использовать, мы выделим два
      аспекта кода: вычисление значений и взаимодействие с окружающей средой. В
      в то же время мы поговорим о том, насколько прозрачным или нет может быть наш код при описании этих аспектов,
      и что мы, программисты, можем с этим поделать.

      */

      // Модель вычисления с подстановкой

      // Давайте начнем с первого аспекта - вычисления значений. Как программисты, мы пишем некоторый
      // код, скажем, метод, и он вычисляет значение, которое возвращается вызывающей стороне этого
      // метода:

      def plusOne(i: Int): Int = i + 1

      val x = plusOne(plusOne(12))
      println(x)

      // Вот некоторые из того, что мы можем сказать об этом коде:

      // plusOne - это метод, который принимает аргумент Int и выдает значение Int.
      // Мы часто говорим о сигнатуре типа или просто сигнатуре метода.
      // plusOne имеет сигнатуру типа Int => Int, которая произносится как "от Int до Int" или
      // "plusOne - это функция от Int до Int".

      // x - это значение. Оно определяется как результат вычисления выражения plusOne(plusOne(12)).

      // Давайте используем подстановку для вычисления этого кода. Мы начинаем с выражения
      // plusOne(plusOne(12)) и заменяем каждое (вспомогательное) выражение его определением,
      // рекурсивно повторяется до тех пор, пока больше не останется подвыражений:


      // Мы показываем процесс подстановки в виде “различия”, которое вы можете увидеть в обзоре кода.
      // Исходное выражение выделено красным цветом с префиксом -,
      // а результат подстановки выделен зеленым цветом с префиксом +.

     /*
              1. Replace the inner plusOne(12) with its definition:
                - val x = plusOne(plusOne(12))
                + val x = plusOne(12 + 1)
              2. Replace 12 + 1 with 13:
                - val x = plusOne(12 + 1))
                + val x = plusOne(13)
              3. Replace plusOne(13) with its definition:
                - val x = plusOne(13)
                + val x = 13 + 1
              4. Replace 13 + 1 with 14:
                - val x = 13 + 1
                + val x = 14
      */

      // Важно отметить некоторые особенности этого примера:
      // 1. Чтобы понять, что делает plusOne, вам не нужно искать ничего, кроме
      // (буквального) определения plusOne. Здесь нет ссылок на что-либо за его пределами.
      // Это иногда называют локальным рассуждением.

      // 2. Под подстановкой программы подразумевают одно и то же, если они вычисляют одно и то же значение.
      // 13 + 1 означает в точности то же, что и 14.
      // То же самое означает плюс один (12 + 1) или даже (12 + 1) + 1.
      // Это называется ссылочной прозрачностью.

      // Цитирую самого себя, когда я читал вводный курс по функциональному программированию:
      // “подстановка настолько глупа, что даже компьютер может это сделать!”.
      // Было бы замечательно, если бы все программы были такими же автономными, как plusOne,
      // чтобы мы, люди, могли использовать подстановку для оценки кода и получения того же значения, что и компьютер.

      // Но подстановка - это всего лишь модель того, как происходит фактическое вычисление.
      // Она не обрабатывает все виды выражений. Когда происходит сбой в замене? Можете ли вы привести несколько примеров?

      // Вот некоторые из них, о которых вы, возможно, подумали:

      // 1. При печати на консоли. Функция println выводит строку на консоль и возвращает тип Unit.
      // Если мы применим замену,

      /*
            - val x = println("Hello world!")
            + val x = ()
      */

      // значение — эффект — первого выражения сильно отличается от второго.
      // Во втором выражении ничего не выводится. Использование подстановки не приводит к желаемому результату.

      // 2. При считывании значений из внешнего мира. Если мы применим замену,

      /*
            - val name = readLine
            + val name = <whatever you typed in the console>
      */

      // значение name соответствует любой конкретной строке, которая была считана из консоли,
      // но эта конкретная строка не совпадает с вычислением выражения readLine.
      // Выражение readLine может быть вычислено как-то иначе.

      // 3. Когда выражения ссылаются на изменяемые переменные.
      // Если мы взаимодействуем с изменяемыми переменными, значение выражения зависит от
      // любого возможного изменения переменной.
      // В следующем примере, если какой-либо код изменит значение i, то это также изменит вычисление x.

      /*
              var i = 12
              - val x = { i += 1; i }
              + val x = 13
      */

      // Этот пример очень похож на предыдущий: вы могли бы рассматривать ввод текста в консоль
      // как запись в изменяемую переменную, содержимое которой возвращает readLine.

      // Борьба с побочными эффектами

      // Вторым аспектом эффектов, после вычисления значений, является взаимодействие с окружающей средой.
      // И, как мы видели, это может нарушить подстановку.
      // Среды могут меняться, они недетерминированы, поэтому выражения, связанные с ними,
      // не обязательно приводят к одному и тому же значению.
      // Если мы используем изменяемое состояние, если мы выполняем скрытые побочные эффекты — если мы нарушаем подстановку —
      // все ли потеряно? Нисколько.

      //Один из способов сохранить способность рассуждать о коде - это локализовать “нечистый” код, который нарушает подстановку.
      // Для внешнего мира код будет выглядеть так — и вычисляться — как будто происходит подстановка.
      // Но внутри границы есть драконы:

      def sum(ints: List[Int]): Int = {
        var sum = 0
        ints.foreach(i => sum += i)
        sum
      }
      val s =  sum(List(1, 2, 3))

      // Мы использовали изменяемую переменную. Ужас! Но ничто, кроме sum, не может повлиять на нее.
      // Ее существование ограничено одним вызовом.
      // Когда мы вычисляем выражение, использующее sum, мы получаем детерминированный ответ.
      // На этом уровне работает подстановка.

      // Мы оптимизировали, спорным образом, код для вычисления суммы по списку, поэтому вместо использования
      // неизменяемого фолдинга по списку мы обновляем локальную переменную.
      // С точки зрения вызывающей стороны, подстановка сохраняется.
      // В нечистом коде мы не можем использовать аргументы, которые дает нам подстановка, поэтому, чтобы доказать самим себе,
      // что код работает правильно, нам придется использовать другие методы, которые выходят за рамки этой книги.

      // Локализация - хороший трюк, но он не сработает для всего, что нарушает подстановку.
      // Нам нужны побочные эффекты, чтобы действительно что-то делать в наших программах, но побочные эффекты - это небезопасно!
      // Что мы можем сделать?

      // The Effect Pattern

      // Если мы выполним некоторые условия, то сможем превратить побочные эффекты в нечто более безопасное;
      // мы будем называть их эффекты.
      // Они состоят из двух частей:

      // 1. Тип программы должен указывать нам, какие эффекты она будет выполнять, в дополнение к типу создаваемого значения.
      // Одна из проблем с нечетким кодом заключается в том, что мы не можем видеть, что он нечеткий!
      // Внешне это выглядит как метод или блок кода. Присвоив эффекту тип, мы можем отличить его от другого кода.
      // В то же время мы продолжаем отслеживать тип результата вычисления.

      // 2. Если желаемое нами поведение зависит от какого-либо видимого извне побочного эффекта,
      // мы отделяем описание эффектов, которые мы хотим получить, от их реального воплощения.
      // Мы можем свободно заменять описание эффектов до тех пор, пока не запустим их.
      // Эта идея в точности совпадает с идеей локализации, за исключением того, что вместо того,
      // чтобы выполнять побочный эффект на самом внутреннем уровне кода и скрывать его от внешних уровней,
      // мы задерживаем побочный эффект, чтобы он выполнялся вне какого-либо вычисления,
      // гарантируя, что подстановка все еще выполняется внутри.

      // Мы назовем эти условия шаблоном эффектов и применим его к изучению и
      // описанию эффектов, которые мы используем каждый день, а также к новым видам эффектов.

      // Контрольный список шаблонов эффектов
      // 1. Указывает ли тип программы на то,
      //      а. какие эффекты программа будет выполнять; и
      //      б. какой тип значения она будет создавать?
      // 2. Когда требуются побочные эффекты, видимые извне, описание эффекта
      //  должно быть отделено от процесса выполнения?

      // О каких эффектах вы можете подумать? Удовлетворяют ли они обоим правилам? В чем вы уверены?
      // Давайте проанализируем два часто используемых типа, Option и Future,
      // в соответствии с критериями эффекта Шаблона. Есть ли эффекты?
      // Присутствуют ли побочные эффекты и безопасно ли с ними бороться?

      // Пример: Является ли Option эффектом?

      // Многие языки, включая Scala, допускают использование значения null для обозначения
      // отсутствия значения. Затем программист (вы!) должен проверить, является ли значение null или нет,
      // в противном случае во время выполнения возникает страшное исключение NullPointerException.

      /*
            def isValid(filename: String) =
              filename.length > 0 && filename.startsWith("/")

            val isvalid = isValid(null)
      */

      // Будьте осторожны, исключений Nullpointerexception предостаточно.

      // Чтобы мы не забыли проверить, в каком случае мы находимся, Scala предлагает другой
      // способ кодирования необязательности в виде алгебраического типа данных:

      /*
            sealed trait Option[+A]
            case class Some[A](value: A) extends Option[A]
            case object None extends Option[Nothing]
      */

      // Option[A] - эффект? Давайте проверим критерии

      // 1. Указывает ли Option[A] нам, какие эффекты будет выполнять программа,
      // в дополнение к типу значения, которое она будет генерировать?
      // Да: если у нас есть значение типа Option[A], мы знаем,
      // это эффект необязательности из имени Option, и мы знаем,
      // что это может привести к получению значения типа A из тайп-параметра A.

      // 2. Требуются ли видимые извне побочные эффекты?
      // Реально нет. Тип данных Option - это интерфейс, представляющий возможность выбора, который
      // поддерживает подстановку. Мы можем заменить вызов метода его реализацией , и смысл программы не изменится.
      // Есть одно исключение — каламбур, — когда может возникнуть побочный эффект, видимый извне:

       /*
             def get(): A =
                this match {
                  case Some(a) => a
                  case None => throw new NoSuchElementException("None.get")
                }
       */

      // Вызов функции get для параметра None является ошибкой программиста и вызывает исключение, которое, в
      // свою очередь, может привести к печати трассировки стека. Однако этот побочный эффект не
      // является основой концепции исключений, это просто реализация обработчика
      // исключений по умолчанию. Суть исключений заключается в нелокальном потоке управления: переходе
      // к обработчику исключений в динамической области, что в совокупности не является
      // видимым извне побочным эффектом.

      // При соблюдении этих двух критериев мы можем сказать, что да, Option[А] - это эффект!

      // Может показаться странным называть Option эффектом, поскольку он не вызывает никаких побочных
      // эффектов. Суть первого условия шаблона эффектов заключается в том, что тип должен
      // делать наличие эффекта видимым. Как мы уже упоминали, традиционной альтернативой
      // Option было бы использование нулевого значения, но тогда как вы могли бы определить, что значение
      // типа A может быть нулевым или нет? Некоторые типы, которые могут иметь нулевое значение, не
      // предназначены для использования концепции отсутствующего значения.
      // Option делает это различие очевидным.

      // Контрольный список шаблонов эффектов: Option[A]
      // 1. Указывает ли тип программы на то,
      //     a. какие эффекты программа будет выполнять;
      //      Тип параметра представляет собой необязательность.
      //     Необязательность означает, что значение может существовать (а может и не существовать).
      //     b. какой тип значения это даст?
      //      Значение типа A, если таковое существует.
      // 2. Когда требуются побочные эффекты, видимые извне, описание эффекта
      //     должно быть отделено от выполнения?
      //      Никаких побочных эффектов, видимых извне, не требуется.
      //      Следовательно, Option - это эффект.

      // Пример: Является ли Future эффектом?
      // В Future, как известно, возникают проблемы, которые нелегко увидеть. Например, посмотрите на этот
      // код, где мы ссылаемся на одно и то же Future, чтобы запустить его дважды:

      val print: Future[Unit] = Future(println("Hello World!"))
      val twice: Future[Unit] = print.flatMap(_ => print)

      // Какая вывод производится?
      // Hello World!
      // Он печатается только один раз! Почему это так?

      // Причина в том, что Future планируется запустить сразу после создания.
      // Таким образом, побочный эффект проявится (почти) немедленно, даже если другие “описательные” операции — последующая печать
      // на flatMap — будут выполнены позже. То есть мы описываем выполнение печати дважды, но побочный эффект выполняется только один раз!
      // Сравните это с тем, что происходит, когда мы заменяем определение печати на дважды:

      println("------------------")

      // 1. Замените первую ссылку для печати на ее определение:
      /*
              val print = Future(println("Hello World!"))
              val twice =
                - print
                + Future(println("Hello World!"))
                  .flatMap(_ => print)
      */

      // 2. Замените вторую ссылку на print на ее определение и удалите
      // определение print, поскольку оно было подключено.
      /*
            - val print = Future(println("Hello World!"))
            val twice =
              Future(println("Hello World!"))
              - .flatMap(_ => print)
              + .flatMap(_ => Future(println("Hello World!")))
       */

      // Теперь у нас есть:

      val twice2 =
        Future(println("Hello World!"))
          .flatMap(_ => Future(println("Hello World!")))

      // Запустив его, мы затем увидим:
      // Hello World!
      // Hello World!

      // Вот почему мы говорим, что Future - это не эффект: замена выражений их
      // определениями не имеет того же значения.

      // Контрольный список шаблонов эффектов: Future[A]
      // 1. Определяет ли тип программы :
      //     a. какие эффекты будет выполнять программа;
      //      Будущее представляет собой асинхронное вычисление.
      //     b. какой тип значения оно будет генерировать?
      //      Значение типа A, если асинхронное вычисление завершилось успешно.
      // 2. Когда требуются побочные эффекты, видимые извне, описание эффекта должно быть отделено от выполнения?
      //      Требуются побочные эффекты, видимые извне: тело будущего может выполнять все, что угодно,
      //     включая побочные эффекты.
      //      Но эти побочные эффекты не проявляются после описания
      //     составные операции; выполнение запланировано сразу после создания.
      //  Таким образом, Future не отделяет описание эффекта от выполнения: это небезопасно.

      // Посмотрите картинку говорящую чем Future небезопасно :)
      // resources/cats.png


      Thread.sleep(100)

      println("-----------------------")
      // Захват произвольных побочных эффектов в качестве эффекта

      // Мы рассмотрели тип эффекта Option, который не предполагает побочных эффектов, и
      // рассмотрели, почему Future не является эффектом.
      // А как насчет эффекта, который действительно имеет побочные эффекты, но безопасен?
      // Для этого и предназначен тип эффекта IO в cats.effect.
      // Это тип данных, который позволяет нам фиксировать любой побочный эффект, но безопасным способом, следуя нашему шаблону эффектов.
      // Сначала мы создадим нашу собственную версию IO, чтобы понять, как она работает.
      // Давайте создадим наш первый эффект: мы хотим фиксировать произвольные побочные эффекты.
      // Мы продемонстрируем это, описав эффект для вывода строки на консоль,
      // а затем впоследствии выполните его.

      object firstio {

        case class MyIO[A](unsafeRun: () => A)

        object MyIO {
          def putStr(s: => String): MyIO[Unit] =
            MyIO(() => println(s))
        }

      }

      object helloexec {
        import firstio._

        val hello: MyIO[Unit] = MyIO.putStr("hello!")
      }



      helloexec.hello.unsafeRun()

      // Побочный эффект, который мы хотим отсрочить, фиксируется как небезопасный запуск функции.
      // Мы назвали его небезопасный запуск, потому что хотим, чтобы все знали, что эта функция не поддерживает подстановку.

      // Наш эффект печати putStr определяется путем создания значения MyIO,
      // которое задерживает выполнение функции println.

      // Мы описываем вывод "hello!" как значение MyIO. Но это еще не было выполнено.

      // Здесь мы явно запускаем эффект.

      // Если мы запустим программу печати, она выведет:
      // hello!
      // Для программы печати давайте проверим, поддерживает ли MyIO подстановку, рекурсивно заменяя
      // каждое выражение его определением.

      // 1. Наша оригинальная программа:
      /*
              object Printing extends App {
                val hello = MyIO.putStr("hello!")
                hello.unsafeRun()
              }
      */

      // 2. Замените значение hello на его определение MyIO.putStr("привет!").:
      /*
                - val hello = MyIO.putStr("hello!")
                -
                - hello.unsafeRun()
                + MyIO.putStr("hello!")
                +    .unsafeRun()
      */

      // 3. Замените выражение My IO.puts на его определение MyIO(() => println("привет")):
      /*
              - MyIO.putStr("hello!")
              + MyIO(() => println("hello!"))
                     .unsafeRun()
      */

      // 4. Замените выражение unsaferun() на его определение, которое вычисляет сам unsafeRun:
      /*
              - MyIO(() => println("hello!"))
              -     .unsafeRun()
              + println("hello!")
      */

      // После рекурсивной подстановки выражений программы на ее определения текст
      // программы для печати эквивалентен выражению println("привет!").
      // Итак, да, MyIO поддерживает подстановку: после каждого вычисления значение программы сохраняется.

      println("-----------------------")

      // Композиция эффектов

      // Мы можем создавать отдельные эффекты и запускать их, но как мы можем их комбинировать?
      // Мы можем захотеть изменить вывод эффекта (с помощью map)
      // или использовать вывод эффекта для создания нового эффекта (с помощью flatMap).
      // Давайте добавим эти методы в наш MyIO.
      // Но будьте осторожны! При создании эффектов они не должны выполняться.
      // Нам требуется, чтобы композиция поддерживала подстановку, поэтому мы можем создавать эффекты из других эффектов.

      object secondio {

        case class MyIO[A](unsafeRun: () => A) {
          def map[B](f: A => B): MyIO[B] =
            MyIO(() => f(unsafeRun()))

          def flatMap[B](f: A => MyIO[B]): MyIO[B] =
            MyIO(() => f(unsafeRun()).unsafeRun())
        }

        object MyIO {
          def putStr(s: => String): MyIO[Unit] =
            MyIO(() => println(s))
        }

      }


      object helloworldexec {

        import secondio._

        val hello = MyIO.putStr("hello!")
        val world = MyIO.putStr("world!")

        val helloWorld: MyIO[Unit] = for {
          _ <- hello
          _ <- world
        } yield ()

      }

      helloworldexec.helloWorld.unsafeRun()

      // Определение map простое: мы создаем новый MyIO, который должен возвращать значение типа B.
      // Как мы можем получить значение B? У нас есть функция A ⇒ B,
      // так где же мы можем получить значение A? Мы используем unsafeRun.

      // Определение flatMap немного сложнее. Мы снова создаем новый MyIO, который должен возвращать значение B.
      // Мы вызываем f с выводом unsafeRun, но это дает нам MyIO[B], а не B.
      // Но если мы вызовем unsafeRun для этого MyIO, он выдаст нужное нам значение B.
      // Это определение согласуется с тем, что должен делать flatMap:
      // он выполняет последовательность двух операций, где одна выполняется перед другой.

      // Мы объединяем эффекты hello и world, используя for-comprehension (которая использует flatMap),
      // и их композиция возвращает единый эффект.

      // Запуск программы печати производит:
      // hello!
      // world!

      println("-----------------------")

      // Exercise 1: Timing
      // Code available at effects/Timing.scala.


      /*
                  package com.innerproduct.ee.effects
                  import scala.concurrent.duration.FiniteDuration
                  object Timing extends App {
                    val clock: MyIO[Long] =
                      ??? 1
                    def time[A](action: MyIO[A]): MyIO[(FiniteDuration, A)] =
                      ??? 2
                    val timedHello = Timing.time(MyIO.putStr("hello"))
                    timedHello.unsafeRun() match {
                      case (duration, _) => println(s"'hello' took $duration")
                    }
                  }

      1 Write a clock action that returns the current time in milliseconds, i.e., via
        System.currentTimeMillis.
      2 Write a timer that records the duration of another action.

      */

      import secondio._

      object Timing {
        val clock: MyIO[Long] = MyIO(() => System.currentTimeMillis)

        def time[A](action: MyIO[A]): MyIO[(FiniteDuration, A)] = for {
          start <- clock
          a <- action
          end <- clock
        } yield (FiniteDuration(end - start, TimeUnit.MILLISECONDS), a)

      }

      val timedHello = Timing.time(MyIO.putStr("hello"))

      timedHello.unsafeRun() match {
        case (duration, _) => println(s"'hello' took $duration")
      }

      // Мы захватываем текущее время, которое не учитывает подстановку, в MyIO.

      // Мы используем for-comprehension для определения последовательности нескольких эффектов:
      // сначала мы фиксируем время начала, затем выполняем наш эффект,
      // затем фиксируем время окончания, чтобы рассчитать продолжительность действия.

      // Запуск программы Timing продуцирует:
      // hello!
      // 'hello' took 66 milliseconds

      // MyIO как эффект
      // Давайте сравним MyIO с нашим шаблоном эффектов:

      // Контрольный список шаблонов эффектов: MyIO[A]
      // 1. Указывает ли тип программы на:
      //     a. какие эффекты будет выполнять программа;
      //      MyIO представляет собой (возможно) побочное вычисление.
      //     b. какой тип значения оно будет генерировать?
      //      Значение типа A, если вычисление завершилось успешно.
      // 2. Когда требуются видимые извне побочные эффекты, описание эффекта должно быть отделено от выполнения?
      //      Требуются видимые извне побочные эффекты: при выполнении MyIO может выполнять все, что угодно, включая побочные эффекты.
      //      Мы описываем значения MyIO , конструируя их и составляя с помощью map и flatMap.
      //        Эффект выполняется только при вызове unsafeRun.
      //  Следовательно, MyIO - это эффект!

      // Удовлетворяя шаблону эффектов, мы знаем, что наш тип эффекта MyIO безопасен в использовании,
      // даже при программировании с побочными эффектами.
      // В любой момент перед вызовом unsafeRun мы можем положиться на подстановку, и, следовательно,
      // мы можем заменить любое выражение на его значение — и наоборот - для безопасного рефакторинга нашего кода.
      // В следующей главе мы представим тип cats.effect.IO, который создается с использованием тех же методов,
      // что и наш более простой тип MyIO.


      // Что такое “thunk” ?
      // Хотя мы не используем этот термин в этой книге, вы можете увидеть ссылку на него,
      // читая о функциональном программировании, программировании с эффектами или множестве других предметов.
      // Например, вы можете увидеть фразу типа “передайте thunk в качестве первого аргумента метода”. Что такое “thunk”?
      // Thunk - это просто отложенное вычисление. Название представляет собой каламбур прошедшего
      // времени от слова “think”.

      // https://en.wikipedia.org/wiki/Thunk

      // При желании thunk может сохранять свой результат в памяти, избегая повторных вычислений при последующей оценке.
      // Скорее всего, вы сталкивались с thunk в Scala в качестве параметра вызова по имени:

      def doSomething[A](thunk: => A) = ???

      // Всякий раз, когда он вычисляется, thunk выдает значение типа A

      // Параметры вызова по имени сами по себе не могут быть значениями, поэтому функция thunk
      // в качестве альтернативы может иметь сигнатуру типа () ⇒ A: функция с нулевым аргументом, которая
      // при вычислении выдает значение типа A. Например, мы использовали эту форму
      // в нашем типе данных MyIO, где она содержала thunk с именем unsafeRun, потому
      // что мы требуем, чтобы эффекты задерживали их выполнение:


     /*
            case class MyIO[A](unsafeRun: () => A)
     */

      // Иногда терминология немного размывается, и кто-то может сказать , что значение типа MyIO - это thunk,
      // поскольку вы можете использовать его для выполнения отложенных вычислений, а не для его более буквальной интерпретации.
      // Обе интерпретации могут быть полезны.


      // Резюме

      // 1. Модель подстановки при оценке дает нам локальное мышление и бесстрашный рефакторинг.

      // 2. Взаимодействие с окружающей средой может нарушить замещение.
      // Одним из решений является локализация этих побочных эффектов, чтобы они не влияли на оценку.

      // 3. Другим решением является шаблон эффекта: набор условий, который делает
      // наличие эффектов более заметным, обеспечивая при этом сохранение подстановки.
      // Тип эффекта указывает нам, какие эффекты будет выполнять программа, в дополнение к типу значения,
      // которое она будет генерировать.
      // Эффекты отдельно описывают то, что мы мы не хотим, чтобы это произошло, а фактически осуществляем это.
      // Мы можем свободно заменять описание эффектов вплоть до того момента, когда мы их запустим.

      // 4. Мы продемонстрировали способ безопасного учета побочных эффектов с помощью типа MyIO[A],
      // который задерживает побочный эффект до тех пор, пока не будет вызван метод unsafeRun.
      // Мы создали новые значения MyIO с помощью комбинаторов map и flatMap.

    }

  }
    part1.preface
    part1.chapter1


}

