

import cats.{Functor, Monad}

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.duration.DurationInt
import scala.concurrent.{Await, Future}
import scala.language.postfixOps
import cats.implicits._

import scala.util.Try


object Main1 extends App {
  println("Изучаем Cats Effect - книга Essential Effects")

  // https://github.com/inner-product/essential-effects-code

  // В этой книге мы покажем изменения в коде в виде “различий”, которые вы можете увидеть в обзоре кода.
  // Исходный код отображается красным цветом с префиксом -,
  // а обновленная версия - зеленым цветом с префиксом +.

  object part1 {
    def preface = {

      println()
      println("====================================== Preface")

      // Предпосылки
      // Essential Effects основана на общем наборе методов функционального программирования:
      //  функторы, аппликативы и монады. Если какие-либо из них вам не знакомы, пожалуйста, ознакомьтесь с ними ниже.
      //  Возможно, вы не знакомы с самими техническими терминами, но, возможно
      //, вы уже знакомы с концепциями и использовали их в своих проектах.

      // Более глубокое погружение в основы функционального программирования можно найти в книгах
      // Essential Scala
      // https://underscore.io/books/essential-scala/

      // Scala with Cats.
      // https://scalawithcats.com/


      // Functors

      // Функтор отражает понятие чего-либо, что вы можете сопоставить, изменяя его
      // “содержимое” (или выходные данные), но не саму структуру.
      // Многие типы позволяют вам сопоставлять их.
      // Например, все эти типы являются функторами:


      val list = List(1, 2, 3).map(_ + 1)
      val opt = Option(1).map(_ + 1)
      val future = Future(1).map(_ + 1)

      println(list)
      println(opt)
      println{
        Await.result(future, 5 seconds)
      }

      // Сигнатура map для некоторого значения типа F[A], где типом F может быть List, Option и т.д.,
      // выглядит следующим образом:

      // def map[B](f: A => B): F[B]

      // В Essential Effects мы будем использовать map довольно часто.
      // Помимо map, мы также будем использовать методы расширения as и void из Functor:

      val fa: Functor[Option] = Functor[Option]

      val replaced1: Option[String] = fa.map(Some(3))(_ => "replacement")
      val replaced2: Option[String] = fa.as(Some(3),"replacement")

      val voided1: Option[Unit] = fa.map(Some(3))(_ => ())
      val voided2 = fa.void(Some(3))

      println(replaced1, replaced2)
      println(voided1, voided2)

      println("------------------------------")

      // Applicatives

      // Аппликативный функтор, также известный как applicative,
      // это функтор, который может преобразовывать несколько структур, а не только одну.
      // Давайте начнем наш пример с того, что сначала применим map к одному
      // значению параметра (это функтор) и расширим его, чтобы продемонстрировать прикладной
      // метод mapN, действующий на кортежи значений:

      val o1: Option[Int] = Option(1).map(_ + 1)
      val o2: Option[Int] = (Option(1), Option(2)).mapN(_ + _ + 1)
      val o3: Option[Int] =  (Option(1), Option(2), Option(3)).mapN(_ + _ + _ + 1)

      // В более общем плане, для некоторого прикладного типа с именем F[_]
      // мы можем составить кортеж значений F в одно значение F, используя map:

      /*
            def map[B](A => B): F[B]
            def mapN[C]((A,B) => C): F[C]
            def mapN[D]((A,B,C) => D): F[D]

            def mapN[Z]((A, ...) => Z): F[Z]
      */

      // В Essential Effects мы будем использовать аппликативные методы для создания нескольких
      // независимых эффектов, например, при параллельных вычислениях.
      // В частности, мы часто будем использовать символьный аппликативный метод *> для создания двух
      // эффектов, но отбрасывать результат первого. Это эквивалентно следующему вызову mapN:

      val first1 = Option("Один")
      val second1 = Option(1)

      val third1_1: Option[Int] = (first1, second1).mapN((_, b) => b)
      val third1_2: Option[Int] = first1 *> second1

      println(third1_1, third1_2)

      // Метод *> включает в себя два эффекта, первый и второй, с помощью map.
      // Если оба эффекта успешны, мы игнорируем значение первого эффекта,
      // возвращая только значение второго эффекта.

      val first2 = Option.empty[String]
      val second2 = Option(1)
      val third2 =  first2 *> second2

      println {
        third2
      }

      val first3 = Option.empty[String]
      val second3 = Option.empty[Int]
      val third3 =  first3 *> second3

      println {
        third3
      }

      println("------------------------------")

      // Monads

      // Монада - это механизм для упорядочивания вычислений: это выполнение вычисления после этого вычисления.
      // Грубо говоря, монада предоставляет метод flatMap для значения F[A]:

      // def flatMap[B](f: A => F[B]): F[B]

      // Мы можем использовать flatMap некоторой монады F[_] для упорядочивания вычислений:

      def next(a: Int): Option[Int] = Try(10/a).toOption

      val ma1  = Some(5)
      val mb1: Option[Int] = ma1.flatMap(next)
      println(ma1, mb1)

      val ma2  = Some(0)
      val mb2: Option[Int] = ma2.flatMap(next)
      println(ma2, mb2)

      val ma3  = Option.empty[Int]
      val mb3: Option[Int] = ma3.flatMap(next)
      println(ma3, mb3)

      // Производит новое вычисление F[B] на основе (чистого) значения.

      // Поскольку вложенные вызовы flatMap могут усложняться для чтения, когда нам нужно выполнить более двух вычислений,
      // мы можем использовать вместо этого for-comprehension.
      // Это просто синтаксический сахар для вложенных вызовов flatMap:

      def nextB(a: Int): Option[Int] = Try(10/a).toOption
      def nextC(b: Int): Option[String] = Some(b.toString)

      val maa = Option(2)

      val mc1: Option[String] = maa.flatMap{
        a => nextB(a).flatMap{ b =>
          nextC(b)
        }
      }

      val mc2: Option[String] = for {
        a <- maa
        b <- nextB(a)
        c <- nextC(b)
      } yield c

      println(mc1, mc2)


    }

    def chapter1 = {
      println()
      println("====================================== Chapter 1")

      // Эффекты: вычисление и выполнение

      /*

      Мы часто используем термин "эффект", когда говорим о поведении нашего кода, например
      “Каков результат этой операции?” или, при отладке, “Выполнение этого не
      должно иметь эффекта, что происходит?”, где “что происходит?”, скорее
      всего, заменяется ругательством. Но что такое эффект? Можем ли мы точно описать эффекты,
      чтобы писать более совершенные программы, которые мы могли бы лучше понять?
      Чтобы изучить, что такое эффекты и как мы можем их использовать, мы выделим два
      аспекта кода: вычисление значений и взаимодействие с окружающей средой. В
      в то же время мы поговорим о том, насколько прозрачным или нет может быть наш код при описании этих аспектов,
      и что мы, программисты, можем с этим поделать.

      */

      // Модель вычисления с подстановкой

      // Давайте начнем с первого аспекта - вычисления значений. Как программисты, мы пишем некоторый
      // код, скажем, метод, и он вычисляет значение, которое возвращается вызывающей стороне этого
      // метода:

      def plusOne(i: Int): Int = i + 1

      val x = plusOne(plusOne(12))
      println(x)

      // Вот некоторые из того, что мы можем сказать об этом коде:

      // plusOne - это метод, который принимает аргумент Int и выдает значение Int.
      // Мы часто говорим о сигнатуре типа или просто сигнатуре метода.
      // plusOne имеет сигнатуру типа Int => Int, которая произносится как "от Int до Int" или
      // "plusOne - это функция от Int до Int".

      // x - это значение. Оно определяется как результат вычисления выражения plusOne(plusOne(12)).

      // Давайте используем подстановку для вычисления этого кода. Мы начинаем с выражения
      // plusOne(plusOne(12)) и заменяем каждое (вспомогательное) выражение его определением,
      // рекурсивно повторяется до тех пор, пока больше не останется подвыражений:


      // Мы показываем процесс подстановки в виде “различия”, которое вы можете увидеть в обзоре кода.
      // Исходное выражение выделено красным цветом с префиксом -,
      // а результат подстановки выделен зеленым цветом с префиксом +.

     /*
              1. Replace the inner plusOne(12) with its definition:
                - val x = plusOne(plusOne(12))
                + val x = plusOne(12 + 1)
              2. Replace 12 + 1 with 13:
                - val x = plusOne(12 + 1))
                + val x = plusOne(13)
              3. Replace plusOne(13) with its definition:
                - val x = plusOne(13)
                + val x = 13 + 1
              4. Replace 13 + 1 with 14:
                - val x = 13 + 1
                + val x = 14
      */

      // Важно отметить некоторые особенности этого примера:
      // 1. Чтобы понять, что делает plusOne, вам не нужно искать ничего, кроме
      // (буквального) определения plusOne. Здесь нет ссылок на что-либо за его пределами.
      // Это иногда называют локальным рассуждением.

      // 2. Под подстановкой программы подразумевают одно и то же, если они вычисляют одно и то же значение.
      // 13 + 1 означает в точности то же, что и 14.
      // То же самое означает плюс один (12 + 1) или даже (12 + 1) + 1.
      // Это называется ссылочной прозрачностью.

      // Цитирую самого себя, когда я читал вводный курс по функциональному программированию:
      // “подстановка настолько глупа, что даже компьютер может это сделать!”.
      // Было бы замечательно, если бы все программы были такими же автономными, как plusOne,
      // чтобы мы, люди, могли использовать подстановку для оценки кода и получения того же значения, что и компьютер.

      // Но подстановка - это всего лишь модель того, как происходит фактическое вычисление.
      // Она не обрабатывает все виды выражений. Когда происходит сбой в замене? Можете ли вы привести несколько примеров?

      // Вот некоторые из них, о которых вы, возможно, подумали:

      // 1. При печати на консоли. Функция println выводит строку на консоль и возвращает тип Unit.
      // Если мы применим замену,

      /*
            - val x = println("Hello world!")
            + val x = ()
      */

      // значение — эффект — первого выражения сильно отличается от второго.
      // Во втором выражении ничего не выводится. Использование подстановки не приводит к желаемому результату.

      // 2. При считывании значений из внешнего мира. Если мы применим замену,

      /*
            - val name = readLine
            + val name = <whatever you typed in the console>
      */

      // значение name соответствует любой конкретной строке, которая была считана из консоли,
      // но эта конкретная строка не совпадает с вычислением выражения readLine.
      // Выражение readLine может быть вычислено как-то иначе.

      // 3. Когда выражения ссылаются на изменяемые переменные.
      // Если мы взаимодействуем с изменяемыми переменными, значение выражения зависит от
      // любого возможного изменения переменной.
      // В следующем примере, если какой-либо код изменит значение i, то это также изменит вычисление x.

      /*
              var i = 12
              - val x = { i += 1; i }
              + val x = 13
      */

      // Этот пример очень похож на предыдущий: вы могли бы рассматривать ввод текста в консоль
      // как запись в изменяемую переменную, содержимое которой возвращает readLine.

      // Борьба с побочными эффектами

      // Вторым аспектом эффектов, после вычисления значений, является взаимодействие с окружающей средой.
      // И, как мы видели, это может нарушить подстановку.
      // Среды могут меняться, они недетерминированы, поэтому выражения, связанные с ними,
      // не обязательно приводят к одному и тому же значению.
      // Если мы используем изменяемое состояние, если мы выполняем скрытые побочные эффекты — если мы нарушаем подстановку —
      // все ли потеряно? Нисколько.

      //Один из способов сохранить способность рассуждать о коде - это локализовать “нечистый” код, который нарушает подстановку.
      // Для внешнего мира код будет выглядеть так — и вычисляться — как будто происходит подстановка.
      // Но внутри границы есть драконы:

      def sum(ints: List[Int]): Int = {
        var sum = 0
        ints.foreach(i => sum += i)
        sum
      }
      sum(List(1, 2, 3))

      // Мы использовали изменяемую переменную. Ужас! Но ничто, кроме sum, не может повлиять на нее.
      // Ее существование ограничено одним вызовом.
      // Когда мы вычисляем выражение, использующее sum, мы получаем детерминированный ответ.
      // На этом уровне работает подстановка.

      // Мы оптимизировали, спорным образом, код для вычисления суммы по списку, поэтому вместо использования
      // неизменяемого фолдинга по списку мы обновляем локальную переменную.
      // С точки зрения вызывающей стороны, подстановка сохраняется.
      // В нечистом коде мы не можем использовать аргументы, которые дает нам подстановка, поэтому, чтобы доказать самим себе,
      // что код работает правильно, нам придется использовать другие методы, которые выходят за рамки этой книги.

      // Локализация - хороший трюк, но он не сработает для всего, что нарушает подстановку.
      // Нам нужны побочные эффекты, чтобы действительно что-то делать в наших программах, но побочные эффекты - это небезопасно!
      // Что мы можем сделать?

      // The Effect Pattern

      // Если мы выполним некоторые условия, то сможем превратить побочные эффекты в нечто более безопасное;
      // мы будем называть их эффекты.
      // Они состоят из двух частей:

      // 1. Тип программы должен указывать нам, какие эффекты она будет выполнять, в дополнение к типу создаваемого значения.
      // Одна из проблем с нечетким кодом заключается в том, что мы не можем видеть, что он нечеткий!
      // Внешне это выглядит как метод или блок кода. Присвоив эффекту тип, мы можем отличить его от другого кода.
      // В то же время мы продолжаем отслеживать тип результата вычисления.

      // 2. Если желаемое нами поведение зависит от какого-либо видимого извне побочного эффекта,
      // мы отделяем описание эффектов, которые мы хотим получить, от их реального воплощения.
      // Мы можем свободно заменять описание эффектов до тех пор, пока не запустим их.
      // Эта идея в точности совпадает с идеей локализации, за исключением того, что вместо того,
      // чтобы выполнять побочный эффект на самом внутреннем уровне кода и скрывать его от внешних уровней,
      // мы задерживаем побочный эффект, чтобы он выполнялся вне какого-либо вычисления,
      // гарантируя, что подстановка все еще выполняется внутри.


    }

  }
    //part1.preface
    part1.chapter1


}

