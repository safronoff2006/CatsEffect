
import cats.effect.IO.{IOCont, Uncancelable}
import cats.effect.kernel.Outcome
import cats.effect.unsafe.implicits.global
import cats.effect.{ExitCode, IO, IOApp}

import scala.language.postfixOps
import cats.implicits._
import utils.debug._

import scala.concurrent.duration.{DurationInt, FiniteDuration}


object Main1 extends App {
  println("Изучаем Cats Effect - книга Essential Effects")

  // https://github.com/inner-product/essential-effects-code

  // В этой книге мы покажем изменения в коде в виде “различий”, которые вы можете увидеть в обзоре кода.
  // Исходный код отображается красным цветом с префиксом -,
  // а обновленная версия - зеленым цветом с префиксом +.

  object part1 {
    def chapter4 = {
      // Chapter 4. Concurrent control

      // До сих пор мы работали с довольно непрозрачными эффектами: мы можем описать их и в конечном итоге запустить, чтобы получить значение (или ошибку).
      // Но у нас пока нет никакого способа управлять запуском вычислений.

      /*
              val i1: IO[A] = ???     1
              val i2: IO[B] = ???     1
              val i3: IO[C] = doSomething(i1, i2)      1

              val c: C = i3.unsafeRunSync()     2
      */

      // 1 Эти эффекты еще не стартовали. Мы описали только то, что они вычисляют.
      // 2 Мы получаем результат вычисления, когда оно завершено.
      // У нас нет доступа к тому, как оно вычисляется, поэтому мы не можем влиять (контролировать).

      // Поскольку вычисление может выполняться, управлять им означает, что мы будем действовать параллельно с ним.
      // В этой главе мы обсудим, как разветвлять и присоединять параллельный эффект, отменять одновременно выполняющийся эффект
      // и как запускать несколько эффектов одновременно.

      // Конкурентность vs. параллелизм
      // Хотя они часто сплетены, параллельные и параллельные являются неодинаковыми концепции:

      // concurrent
      // Вычисления являются конкурентными, когда время жизни их выполнения перемежаются

      // parallel
      // Вычисления являются параллельными, когда их выполнение происходит в один и тот же момент времени.

      // Иными словами, конкурентность - это взгляд на структуру вычислений и на то, как согласуются их времена жизни,
      // в то время как параллелизм больше связан с оперативным использованием ресурсов во время выполнения.

      // Например, с помощью двух потоков вы могли бы выполнять два вычисления параллельно (и конкурентно!).
      // Но с помощью одного потока вы также могли бы выполнять два вычисления конкурентно: если вы можете “приостановить” одно и переключиться,
      // используя тот же поток, на другое и наоборот, они будут создавать впечатление что выполняться одновременно.

      // resources/parallelism.png
      // Параллелизм - Два потока позволяют выполнять вычисления параллельно в течение выделенного периода. Они также выполняются одновременно.

      // resources/concurrency.png
      // Конкурентность - Два вычисления могут выполняться конкурентно только в одном потоке, если
      // вычисление может быть прервано и возобновлено

      // Конкурентность подчеркивает недетерминированные аспекты вычислений: мы не можем сказать, когда что-то происходит,
      // только то, что время их существования перекрывается.
      // В то время как параллелизм требует детерминизма: независимо от того, сколько у вас ресурсов, вы должны выдавать один и тот же ответ.

      // 4.1. Декомпозиция поведения parMapN

      println("---------------")

      // Чтобы продемонстрировать форк, объединение и отмену параллельных эффектов,
      // мы напишем нашу собственную версию parMapN,  в которой задействован каждый из них.

      def myParMapN[A, B, C](ia: IO[A], ib: IO[B])(f: (A, B) => C): IO[C] = ???

      // myParMapN, как и parMapN, должен:
      // ☐ запускать вычисления ia и ib одновременно, чтобы они выполнялись одновременно (“разветвлять” или "форкать" их);
      // ☐ ожидать каждого результата;
      // ☐ отмените “другой” эффект, если ia или ib не сработают; и
      // ☐, наконец, объедините результаты с помощью функции f.

      // (Мы пишем только вариант parMapN с двумя аргументами, игнорируя другие варианты.)
      // Важно отметить, что для того, чтобы “ждать” и “отменять”, нам понадобится что-то,
      // что будет “ждать” и “отменять”, своего рода дескриптор “начатого” вычисления. В Cats Effect
      // это понятие представляет собой волокно.

      // 4.2. Получение контроля с помощью волокна

      // Когда мы пишем выражение типа

      /*
            for {
              result <- effect
              ...
      */

      // значение результата существует только после того, как оно получено с помощью эффекта.
      // По сути, мы ждем, пока результат не станет доступен, чтобы продолжить вычисление.
      // Вместо того чтобы ждать результата, мы могли бы форкнуть эффект: эффект будет запущен, но мы
      // не заинтересованы в ожидании его завершения.
      // Однако результатом разветвления, будет значением,
      // позволяющим нам управлять эффектом раздвоения: волокно.

      // В Cats Effect для создания эффекта c помощью fork мы будем использовать метод start.
      // Давайте создадим простую программу и рассмотрим ее поведение:

      // Смотрите и запускайте пример Start.

      // 1 Мы запускаем эффект, чтобы разветвить его выполнение от текущего эффекта.
      // 2 Сразу после запуска задачи мы выводим что-то на консоль.

      // Running Start we see the following output:
      //  [ioapp-compute-1] task               1
      //  [ioapp-compute-0] task was started

      // Обратите внимание на эффект выполнения task в потоке io app-computer-1, который отличается от следующего эффекта!

      // Когда вы запускаете эффект, его выполнение “раздваивается”: он переносится в другой поток.

      // Вот (упрощенная) сигнатура start:

      /*
            def start: IO[Fiber[IO, A]]
      */

      // Интересен тип возвращаемого значения — оно возвращает Fiber, тип данных,
      // который позволяет нам воздействовать на эффект started.
      // Но почему start возвращает Fiber внутри IO ?
      // Он возвращает волокно внутри IO, потому что если бы вместо этого он создавал непосредственно волокно,
      // это означало бы, что наш исходный IO запущен прямо сейчас, но на самом деле это не так.
      // Источник IO выполняется только тогда, когда мы явно запускаем его, поэтому нам нужно отложить доступ к этому
      // волокну — обернув его эффектом - до тех пор, пока не будет выполнен IO.

      // Теперь, когда мы продемонстрировали разветвление Fiber, мы считаем необходимым сделать предупреждение:
      // Fiber - это очень “низкоуровневый” механизм параллельного управления.
      // Хотя он абсолютно необходим для реализации конкурентности и параллелизма в Cats Effect,
      // как разработчик, вы часто можете лучше достигать своих целей,
      // используя абстракции и операции более высокого уровня.

      // 4.2.1. Продолжение myParMapN: форк эффектов

      // Мы можем использовать start для форка конкурентного эффекта,
      // поэтому давайте используем его для нашей функции myParMapN:

      /*
              def myParMapN[A, B, C](ia: IO[A], ib: IO[B])(f: (A, B) => C): IO[C] =
                for {
                  fiberA <- ia.start       1
                  fiberB <- ib.start       1
                } yield ???                2
      */

      // 1 Мы запускаем каждый эффект, чтобы запустить их одновременно.
      // 2 Мы пока не знаем, как собрать их результаты или, возможно, отменить их

      // Вот наш прогресс в выполнении требований:
      //  ☑ запустите вычисления ia и ib, чтобы они выполнялись одновременно (“разветвите” их);
      //  ☐ дождитесь каждого результата;
      //  ☐ отмените “другой” эффект, если ia или ib не сработают; и
      //  ☐, наконец, объедините результаты с функцией f.

      // 4.2.2. Подключение к запущенному волокну

      //Когда мы вызываем start для значения IO[A], мы получаем значение Fiber[IO, A].
      // Это позволяет нам говорить о выполнении вычисления IO[A].
      // Что мы можем сделать с волокном? Первое, что мы можем сделать, это присоединиться к нему,
      // что вернет результат эффекта форкнутого IO.
      // Мы отказываемся от управления, предоставленного нам fiber, и впоследствии можем говорить только о конечном результате
      // ранее форкнутого значения.

      val joined =
        for {
          fiber <- IO("task").start
          s <- fiber.join
        } yield s


      // Что произойдет, если мы присоединимся к только что запущенному файберу? Что и в каком потоке выполняется?

      // Смотрите и выполняйте пример JoinAfterStart

      // 1 Мы вводим задержку и отладку для задачи, чтобы помочь нам различать
      // параллельное управление задачей (использование Fiber) и саму задачу.
      // 2 После того, как мы напечатаем наше предварительное сообщение о присоединении, мы вызываем join.
      // Напомним, что метод расширения *> эквивалентен использованию map с двумя эффектами,
      // но создается значение только второго эффекта; например,
      // first *> second эквивалентен (first, second).map((_, b) => b).

      // Running JoinAfterStart outputs:
      // [io-compute-1] pre-join
      // [io-compute-4] task
      // [io-compute-2] Succeeded(IO(task))
      // [io-compute-2] post-join

      // 1 Обратите внимание, что task находится в другом потоке, отличном от вывода "pre-join".
      // Мы также видим, что task выводится дважды, один раз для ввода-вывода ("task").debugio и один раз для
      // fiber.join.debugio.

      // Когда мы присоединяемся к волокну, выполнение продолжается в том потоке,
      // в котором оно было запущено (в данном случае ioapp-compute-1).

      // 4.2.3. Продолжение myParMapN: объединение разветвленных эффектов

      // Теперь, когда мы знаем, что можем дождаться результатов параллельного действия с помощью join, мы
      // можем обновить наш метод myParMapN. Поскольку нам нужны оба результата для вызова нашей
      // функции преобразования f, не имеет значения, в каком порядке мы будем объединять.
      // Но нам действительно нужно объединить обе раздвоенные задачи:

      /*
              def myParMapN[A, B, C](ia: IO[A], ib: IO[B])(f: (A, B) => C) : IO[C] =
                for {
                  fiberA <- ia.start
                  fiberB <- ib.start
                  a <- fiberA.join      1
                  b <- fiberB.join      2
                } yield f(a,b)          3
      */

      // 1 Дождитесь результата разветвления ia по fiberA.
      // 2 Дождитесь результата разветвления ib по fiberB.
      // 3 Как только мы получим оба результата, вычислите желаемое значение.

      // Вот наш прогресс в выполнении требований:
      // ☑ запустите вычисления ia и ib таким образом, чтобы они выполнялись одновременно (“разветвите” их);
      // ☑ дождитесь каждого результата;
      // ☐ отмените “другой” эффект, если ia или ib не сработают; и
      // ☑, наконец, объедините результаты с помощью функции f.

      // Нам все еще нужно сделать отмену.

      // 4.3. Отмена работы файбера.

      // Второе, что мы можем сделать с волокном - это отменить его.

      /*
                def cancel: cats.effect.CancelToken[IO]

                type CancelToken[F[_]] = F[Unit]        1
      */

      // 1 Отмена передачи данных по волокну сама по себе является эффектом.
      // Как только эффект отменяется, он преобразуется в Unit.

      // Почему мы можем захотеть остановить запущенную задачу? Обычно это происходит потому, что мы узнали
      // некоторую информацию, которая говорит нам, что вычисления больше не нужны.
      // Например, мы можем запустить выборку из (относительно медленного) хранилища данных,
      // но если пользователь решит отменить всю операцию, нам следует отменить выборку из базового хранилища данных.

      // Давайте приведем простой пример отмены работы Fiber:
      // Смотрите и запускайте пример Cancel

      // 1 Мы добавляем обратный вызов onCancel для вывода на консоль, если эффект отменен.
      // onCancel - это метод расширения IO, предоставляемый
      // import cats.effect.implicit._.
      // 2 Мы отменяем Fiber после запуска.
      // 3.IO.never - это встроенный непрерывный эффект. Он имеет тип IO[Nothing], поэтому,
      // поскольку type Nothing - это тип без значений, этот эффект никогда не может завершиться.
      // Но его можно отменить.

      // Running Cancel outputs:

          // [io-compute-11] task
          // [io-compute-10] pre-cancel
          // [io-compute-11] i was cancelled
          // [io-compute-10] canceled

      // Обратите внимание, что функция отмены является идемпотентной.
      // Повторный вызов этой функции приводит к тому же эффекту, что и однократный вызов —
      // отмененная задача будет по-прежнему отменяться.
      // Однако, если вы join после отмены, соединение никогда не завершится, поскольку результат не будет получен.

      // 4.3.1. Как отмена работает?

      // Давайте создадим ситуацию, в которой долгоживущий эффект работает одновременно с
      // эффектом, который приводит к ошибке. В первом случае мы будем использовать ранее написанные
      // “тикающие часы”.:

      lazy val tickingClock: IO[Unit] =
        for {
          _ <- IO(System.currentTimeMillis).debugio
          _ <- IO.sleep(1.second)
          _ <- tickingClock
        } yield ()

      // tickingClock.unsafeRunSync()

      // Мы запустим его одновременно с неудачным эффектом, используя parTupled:

      // Мы выдаем сообщение об ошибке через две секунды, чтобы дать тикающим часам возможность напечатать
      // несколько раз на консоли так что, как только возникнет исключение, тиканье часов будет отменено


      object ohNoes {

        val ohNoes = IO.sleep(2.seconds) *> IO.raiseError(new RuntimeException("oh noes!"))
        val together: IO[(Unit, Nothing)] = (tickingClock, ohNoes).parTupled


       def runOhNoes: Unit = {
         val res = together.unsafeRunSync()

       }
      }
      //ohNoes.runOhNoes


      // Наш бесконечно повторяющийся эффект tickingClock прекращается, и мы явно ничего не предпринимали.
      // Так как же работает отмена? И могут ли наши эффекты “знать”, были ли они отменены, и реагировать на эту информацию?
      // Чтобы определить поведение при отмене, Cats Effect использует концепцию границы отмены.
      // При выполнении эффекта, если обнаруживается граница отмены — какой бы она ни была —
      // то проверяется статус отмены для текущего эффекта, и если этот эффект был отменен, то выполнение будет остановлено.
      // С одной стороны, отмена происходит “автоматически”, потому что CatsEffect периодически вставляют границу отмены
      // во врем В качестве альтернативы, вставляя одну границу отмены , можно “вручную” вставить
      // другую во время выполнения отмены эффекта используя IO.cancelBoundary.

      // 4.3.2. Продолжение работы myParMapN: поведение при отмене при ошибке.

      // Если во время одного из наших эффектов возникает ошибка, нам нужно отменить "другое" волокно.
      // Давайте используем комбинатор onError для обработки каждого эффекта:

      /*
            def myParMapN[A, B, C](ia: IO[A], ib: IO[B])(f: (A, B) => C): IO[C] =
              for {
                fiberA <- ia.start
                fiberB <- ib.start
                a <- fiberA.join.onError(_ => fiberB.cancel)     1
                b <- fiberB.join.onError(_ => fiberA.cancel)     2
              } yield f(a, b)
      */

      // 1 Если при вычислении fiberA обнаружена ошибка, отмените fiberB
      // 2 Если при вычислении fiberВ обнаружена ошибка, отмените fiberA.

      // Однако здесь есть критическая ошибка. Можете ли вы догадаться, в чем она заключается?

      // Проблема в том, что регистрация обработчика onError сама по себе является эффектом, поэтому в
      // приведенном выше коде обработчик будет зарегистрирован только в том случае, если мы свяжем его с результатом fibers.join.
      // Но если мы сделаем это, то мы не будем регистрировать обработчик onError с результатом fiberB до тех пор,
      // пока fiber фактически не завершит работу:

      /*
            def myParMapN[A, B, C](ia: IO[A], ib: IO[B])(f: (A, B) => C): IO[C] =
              for {
                fiberA <- ia.start
                fiberB <- ib.start
                a <- fiberA.join.onError(_ => fiberB.cancel)
                b <- fiberB.join.onError(_ => fiberA.cancel)     1
              } yield f(a, b)
      */


      // 1 Обработчик onError для fiberB не будет зарегистрирован до завершения работы fiberA, а это не то, чего мы хотим!
      // Вместо этого нам нужно убедиться, что оба обработчика onError зарегистрированы. Если бы только мы
      //могли написать

      /*
            for {
              fa <- ia.start
              fb <- ib.start
              faj = fa.join.onError(_ => fb.cancel)
              fbj = fb.join.onError(_ => fa.cancel)
              c <- myParMapN(
                fa.join.onError(_ => fb.cancel),
                fb.join.onError(_ => fa.cancel))(f)
            } yield c
      */

      // но это означало бы использование метода, который мы пытаемся написать! (И это
      // неправильно обработало бы отмену). Если бы мы попробовали что-то “умное”, например

      /*
                  for {
                    fa <- ia.start
                    fb <- ib.start
                    faj = fa.join.onError(_ => fb.cancel)
                    fbj = fb.join.onError(_ => fa.cancel)
                    registerA <- faj.start                  1
                    registerB <- fbj.start                  1
                    a <- registerA.join
                    b <- registerB.join
                    c = f(a, b)
                  } yield c
      */

      // 1 Попытка зарегистрировать оба обработчика onError путем разветвления (еще раз).

      // это также не будет должным образом обрабатывать отмену: если один из эффектов отменен, то
      // последующее объединение никогда не будет завершено.

      // Мы застряли: нам нужно избегать объединения с потенциально отмененным эффектом, но
      // здесь любой эффект может быть отменен первым — мы не знаем, какой именно. Интерфейс Fiber API
      // недостаточно выразителен, чтобы предоставить нам необходимую информацию.
      // Чтобы решить проблему, нам нужна другая “примитивная” операция: вместо этого мы запустим два эффекта, что
      // позволит нам узнать, какой из них завершится первым, чтобы мы могли впоследствии присоединиться к другому эффекту.

      // 4.4. Гонки нескольких эффектов

      // Когда мы создаем несколько эффектов одновременно с помощью parMapN,
      // мы предоставляем функцию для преобразования собранных выходных данных каждого rконкурентно  выполняющегося эффекта.
      // Что, если бы вместо этого нас интересовал только тот эффект, который завершился первым, связав их во времени.
      // Мы называем это гонкой и можем создать ее с помощью комбинатора IO.race :

      /*
            def race[A, B](lh: IO[A], rh: IO[B])(implicit cs: ContextShift[IO]): IO[Either[A, B]]
      */

      // Вы можете думать о race похоже как parTupled — оба эффекта запускаются одновременно,
      // но parTupled дает вам оба результата (первый и второй), тогда как race дает вам только один (первый или второй).:

      /*
              val ia: IO[A] = ???
              val ib: IO[B] = ???

              (ia, ib).parTupled    // IO[(A, B)]          1
              IO.race(ia, ib)       // IO[Either[A, B]]    2

              1 The produced (A, B) is an A and a B.
              2 The produced Either[A, B] is either an A or a B.
      */

      // Один из особенно полезных видов гонки - это тайм-аут для эффекта: мы проводим гонку между эффектом
      // и соответствующим эффектом “сна”. Если сон заканчивается  основного эффекта, наступает тайм-аут.

      // Смотрите и запускайте пример Timeout.

      // 1 IO.race запускает два эффекта и возвращает значение для первого финишировавшего.
      // Проигравший в гонке отменяется.
      // 2 done - это значение типа Either[Unit, Unit]. Мы используем шаблон сопоставления для каждого случая.
      // 3 Если оно было левым, то задача завершалась первой, и тайм-аут отменялся.
      // 4 Если оно было правым, то тайм-аут завершался первым, и задача отменялась.
      // 5 Здесь мы создаем эффект ожидания на заданную продолжительность.
      // 6 Что произойдет, если мы изменим длительность на 1000 миллисекунд?

      // Running this program prints out:

        // [io-compute-4]  task: starting
        // [io-compute-8] timeout: starting
        // [io-compute-4]  task: done
        // [io-compute-3] timeout: cancelled
        // [io-compute-3]  task: won


      // Этот шаблон настолько распространен, что в него встроен комбинатор: IO.timeout. Приведенный
      // выше пример можно было бы переписать, как показано ниже, хотя мы теряем возможность напрямую определять,
      // произошел тайм-аут или нет:

      /*
              +  _ <- task.timeout(500.millis) 1
              -  done <- IO.race(task, timeout)
              -  _ <- done match {
              -       case Left(_) => IO(" task: won").debug
              -       case Right(_) => IO("timeout: won").debug
              - }
      */

      //1 Вызывает java.util.concurrent.TimeoutException, если эффект длится дольше, чем
      // время ожидания.

      // Если вы действительно хотите действовать при наступлении таймаута, а не только
      // отменять эффект, вы можете использовать метод IO.timeout,
      // который позволяет вам указать альтернативное значение IO для оценки истечения таймаута.

      // 4.4.1. Гонки без автоматической отмены

      // IO.race построен на более простом комбинаторе IO.racePair, который не обеспечивает
      //отмены эффекта “проигрыша”. Вместо этого вы получаете значение “победитель” вместе
      // с показателем “проигравший” в гонке, так что вы можете решить, что с этим делать.

      /*
         def racePair[A, B](lh: IO[A], rh: IO[B])(implicit cs: ContextShift[IO]): IO[Either[(A, Fiber[IO, B]), (Fiber[IO, A], B)]]
      */

      // 1 Если какой-либо из эффектов приводит к ошибке, другой отменяется.

      // С помощью racePair мы можем завершить реализацию функции отмены при ошибке для myParMapN:

      /*
      def myParMapN[A, B, C](ia: IO[A], ib: IO[B])(f: (A, B) => C): IO[C] =
        IO.racePair(ia, ib).flatMap {
          case Left((a, fb)) => (IO.pure(a), fb.join).mapN(f)        1
          case Right((fa, b)) => (fa.join, IO.pure(b)).mapN(f)       1
        }
      */

      // 1 Если ошибок не возникнет, мы определим, какое из значений завершится первым, перенесем значение, используя IO.pure
      // (оно уже вычислено, поэтому нам не нужно использовать IO.delay), а затем объединим
      // остальные значения до завершения. Наконец, мы объединим значения IO с нашей функцией f.

      // Мы закончили с myParMapN:
      // ☑ запустите вычисления ia и ib, чтобы они выполнялись одновременно (“разветвите” их);
      // ☑ дождитесь каждого результата;
      // ☑ отмените “другой” эффект, если ia или ib не сработают; и
      // ☑, наконец, объедините результаты с функцией f.

      // Если вы чувствуете себя немного обманутым, полагаясь на то, что racePair зарегистрирует отмену для нас, ничего
      // страшного, вы имеете право на это. Само по себе Fiber не дает нам достаточного
      // контроля, чтобы реализовать отмену в случае ошибки.

      // 4.5. Резюме

      // 1. Конкурентностть  позволяет нам управлять выполняемыми вычислениями.
      // 2. Fiber - это наш дескриптор для этого элемента управления.
      // После того, как мы запустим параллельное вычисление,
      // мы можем отменить его или присоединиться к нему (дождаться завершения).
      // 3. Одновременно выполняемые эффекты могут быть отменены. Ожидается, что отмененные эффекты
      // перестанут выполняться из-за неявных или явных границ отмены.
      // 4. Мы можем запустить два вычисления наперегонки, чтобы узнать, кто закончил первым.
      // Эффекты более высокого порядка, такие как тайм-ауты, могут быть созданы с помощью гонок.


      // Реализация myParMapN которая  написана выше - для Cats Effect 2, а для Cats Effect 3 она НЕ КОМПИЛИРУЕТСЯ
      // потому что сигнатура метода join на файбере другая..
      // Я (Валерий Сафронов) переписал реализацию myParMapN для Cats Effect 3, чтобы она компилировалась с Cats Effect 3.
      // Unit тест я напишу несколько позже...и тогда порадую что не только уверен в корректности реализации, но и ОТТЕСТИРОВАЛ.

      def myParMapN[A, B, C](ia: IO[A], ib: IO[B])(f: (A, B) => C): IO[C] =
        IO.racePair(ia, ib).flatMap {
          case Left((a, fb)) =>
            val oA: IO[A] = a.embed( onCancel = throw new Exception("Прерван эффект ia"))
            val oB: IO[B] = fb.join.flatMap ( joined => joined.embed( onCancel = throw new Exception("Прерван эффект ib") ))
            (oA, oB).mapN(f)

          case Right((fa, b)) =>
            val oA: IO[A] = fa.join.flatMap(joined => joined.embed( onCancel = throw new Exception("Прерван эффект ia") ))
            val ob: IO[B] = b.embed( onCancel = throw new Exception("Прерван эффект ib"))
            (oA, ob).mapN(f)
        }
    }

  }

  part1.chapter4




}

object Start extends IOApp {
  def run(args: List[String]): IO[ExitCode] =
    for {
      _ <- task.start
      _ <- IO("task was started").debugio
    } yield ExitCode.Success

  val task: IO[String] = IO("task").debugio
}

object JoinAfterStart extends IOApp {
  def run(args: List[String]): IO[ExitCode] =
    for {
      fiber <- task.start
      _ <- IO("pre-join").debugio
      _ <- fiber.join.debugio
      _ <- IO("post-join").debugio
    } yield ExitCode.Success

  val task: IO[String] =
    IO.sleep(2 seconds) *> IO("task").debugio
}


object Cancel extends IOApp {
  def run(args: List[String]): IO[ExitCode] =
    for {
      fiber <-
        task
          .onCancel(IO("i was cancelled").debugio.void)
          .start

      _ <- IO("pre-cancel").debugio
      _ <- fiber.cancel
      _ <- IO("canceled").debugio

    } yield ExitCode.Success

  val task: IO[String] = IO("task").debugio *> IO.never
}

object Timeout extends IOApp {
  def run(args: List[String]): IO[ExitCode] =
    for {
      done <- IO.race(task, timeout)
      _ <- done match {
          case Left(_) => IO(" task: won").debugio
          case Right(_) => IO("timeout: won").debugio
      }
    } yield ExitCode.Success

  val task: IO[Unit] = annotatedSleep(" task", 100 millis)
  val timeout: IO[Unit] = annotatedSleep("timeout", 500 millis)

  def annotatedSleep(name: String, duration: FiniteDuration): IO[Unit] =
        (
          IO(s"$name: starting").debugio *>
          IO.sleep(duration) *>
          IO(s"$name: done").debugio
        ).onCancel(IO(s"$name: cancelled").debugio.void).void
}

// К каждой из больших глав книги есть СНОСКИ,
// Я их проанализирую и прокомментирую и как то дам ссылки на эти сноски в коде этих примеров...