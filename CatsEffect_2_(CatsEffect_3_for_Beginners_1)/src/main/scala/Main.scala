
import cats.effect.unsafe.implicits.global
import cats.effect.{ExitCode, IO, IOApp}

import scala.concurrent.Future
import scala.language.postfixOps


object Main1 extends App {
  println("Изучаем Cats Effect")

  object part1 {
    def chapter1 = {
      // Введение
      // Cats Effect — одна из самых популярных систем эффектов в Scala.
      // В этой серии статей давайте рассмотрим некоторые из самых важных особенностей Cats Effect.

      // Эта серия предназначена для разработчиков Scala, которые являются полными новичками в Cats Effect.
      // Однако я предполагаю, что читатели знают основы Scala и в основном работали с Future от scala.
      // Обратите внимание, что это не предназначено для объяснения всех функций Cats Effect,
      // а просто для начала работы с Cats Effect. Существует множество других блогов, видео на YouTube и примеров кода,
      // которые подробно объясняют функции.

      // Что такое эффект?
      // Эффект — это описание действия, а не само действие.
      // Он описывает, что может произойти при выполнении действия.

      // Для чего нужна система эффектов?
      // Система эффектов помогает разработчикам контролировать выполнение.
      // Мы можем подробно описывать события и составлять несколько эффектов для создания длинной цепочки связанных эффектов.
      // Затем мы можем выполнять эффекты только тогда, когда это необходимо.
      // Это означает, что система эффектов позволяет нам обрабатывать события лениво.
      // Это невозможно с помощью Future в scala .

      // Давайте рассмотрим это на простом примере:

      implicit val ec = scala.concurrent.ExecutionContext.global

      val futurePrint: Future[Unit] = Future(println("Hello from the Future"))

      // Этот код немедленно начнет выполнение, с нетерпением.
      // Мы не можем контролировать, когда будущее должно быть выполнено.
      // Вот где в игру вступают системы эффектов, такие как Cats-Effect.
      // Это помогает описывать вычисления, но выполнять их по требованию.

      // IO — самый важный и распространенный эффект в Cats-Effect.

      // Как создать IO?
      // Существует несколько способов создания структуры данных IO.
      // Давайте рассмотрим некоторые из них.

      // Используя чистый метод
      // Подобно Future.successful, IO также поддерживает чистый метод для перевода уже выполненного значения в тип IO.

      val scalaIO: IO[String] = IO.pure("Scala")

      // Обратите внимание, что метод IO.pure() следует использовать только в том случае, если значение уже вычислено и доступно.

      // Использование метода «apply»
      // Как и все другие типы в Scala, мы также можем использовать метод apply IO для создания эффекта IO:

      val scalaIOApply: IO[String] = IO("Scala")

      // Использование метода задержки
      // Мы также можем использовать метод IO.delay() для создания структуры данных IO.
      // Это то же самое, что и вызов метода apply.

      val scalaIODelayed: IO[String] = IO.delay("Scala")

      // Существуют более продвинутые способы создания типов ввода-вывода,
      // но мы рассмотрим их в следующих разделах.

      // IO Монада
      // IO — это монада. Нам не нужно углубляться в теоретические концепции монад.
      // На данный момент мы можем предположить, что IO — это тип контейнера, такой как Option, Either, Future и т. д.
      // Мы можем применять общие методы, такие как map, flatMap, identity и т. д. к типам IO.
      // Поскольку у него есть flatMap и identity, мы можем использовать for-comprehension к типам IO, как и Future.

    }


  }

  part1.chapter1


}

// Выполнение эффекта
// Теперь давайте посмотрим, как мы можем выполнить эффект, который мы создали ранее.
// У нас есть в основном 3 способа начать.


// Использование Scala App и метода main()
// Мы можем написать обычный объект Scala и расширить его с помощью App или реализовать метод main . Затем мы можем использовать метод unsafeRunSync() на IO для выполнения эффекта. Однако нам нужно предоставить неявный экземпляр IORunTime . Мы можем предоставить его, импортировав cats.effect.unsafe.implicits.global .
object Main2  {
  val scalaIO = IO(println("Welcome to Cats Effect 3"))

  def main(args: Array[String]): Unit = {
    scalaIO.unsafeRunSync()
  }
}

// Расширение с помощью IOApp
// Вместо использования метода main по умолчанию мы можем использовать предоставленный cats IOApp.
// Нам нужно расширить основное приложение с помощью IOApp и переопределить метод run.
object Main3 extends IOApp {
  val io: IO[Unit] = IO(println("Welcome to Cats Effect 3"))

  override def run(args: List[String]): IO[ExitCode] = io.map(_ => ExitCode.Success)

  // Поскольку метод run должен возвращать IO[ExitCode],
  // мы можем сопоставить наш IO и вернуть необходимый код обратно.
}

// Расширение с помощью IOApp.Simple
// Вместо расширения IOApp,мы можем расширить IOApp.Simple.
// Теперь мы можем реализовать метод run.
// Единственное различие между методом run IOApp и IOApp.Simple заключается в том,
// что метод run IOApp.Simple возвращает IO[Unit], что в целом встречается чаще.
object Main4 extends IOApp.Simple {
  val io: IO[Unit] = IO(println("Welcome to Cats Effect 3"))
  override def run: IO[Unit] = io
}

// Заключение
// В этой статье мы увидели, как создать очень простое приложение с использованием Cats Effect.
// Мы рассмотрим больше функций в следующей части. Пример кода, используемый здесь, доступен на GitHub в пакете part1.
// https://github.com/yadavan88/cats-effect-intro

