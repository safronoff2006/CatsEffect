
import cats.effect.unsafe.implicits.global
import cats.effect.{IO, IOApp}
import cats.effect.cps._

import java.lang.Thread.sleep
import scala.concurrent.duration.DurationInt
import scala.language.postfixOps


object HelloWorld extends IOApp.Simple {
  val run = IO.println("Cats Effect - Hello, World!")
}

object StupidFizzBuzz extends IOApp.Simple {
  val run =
    for {
      ctr <- IO.ref(0)

      wait = IO.sleep(1 second)
      poll = wait *> ctr.get

      _ <- poll.flatMap(IO.println(_)).foreverM.start
      _ <- poll.map(_ % 3 == 0).ifM(IO.println("fizz"), IO.unit).foreverM.start
      _ <- poll.map(_ % 5 == 0).ifM(IO.println("buzz"), IO.unit).foreverM.start

      _ <- (wait *> ctr.update(_ + 1)).foreverM.void
    } yield ()
}

object Main1 extends App {
  println("Изучаем Cats Effect")

  object part1 {
    def chapter1 = {
      val program = IO.println("Hello, World!")
      program.unsafeRunSync()

      lazy val loop: IO[Unit] = IO.println("loop until cancel..") >> IO.sleep(1 seconds) >> loop
      val cancel = loop.unsafeRunCancelable()


      sleep(10000)
    }

    def chapter2 = {

      val io1: IO[Unit] = IO.println("Hello") flatMap { _ =>
        IO.println("World")
      }

      io1.unsafeRunSync()
      println("---------")

      val io2: IO[Unit] = for {
        _ <- IO.println("Hello")
        _ <- IO.println("World")
      } yield ()

      io2.unsafeRunSync()
      println("---------")

      val io3: IO[Unit] = IO.println("Hello") >> IO.println("World")

      io3.unsafeRunSync()
      println("---------")


      val io4 = async[IO] {
        IO.println("Hello").await
        IO.println("World").await
      }

      io4.unsafeRunSync()

      println("---------")

    }

    def chapter3 = {

      //синхронный эффект
      val io = IO.println("Ждите") >> IO(Thread.sleep(1000)) >> IO.println("Hi!")
      io.unsafeRunSync()

      //асинхронный эффект
      import java.util.concurrent.{Executors, TimeUnit}

      val scheduler = Executors.newScheduledThreadPool(1)

      val ioAsync: IO[Unit] = IO.async_[Unit] { cb =>
        scheduler.schedule(new Runnable {
          def run = {
            println("Async Effect!")
            cb(Right(()))
          }
        }, 1000, TimeUnit.MILLISECONDS)

        ()
      }
      // => IO[Unit]

      (IO.println("Ждите 2") >> ioAsync).unsafeRunSync()

      // Оба эффекта Thread.sleep и schedule показанные здесь, имеют одинаковую семантику:
      // они задерживаются на 500 миллисекунд, прежде чем разрешить выполнение следующего шага в волокне.
      // Они отличаются способом, которым они были определены: Thread.sleep - синхронный, в то время как schedule - асинхронный.
      // Последствия этого на удивление глубоки.
      // Поскольку Thread.sleep не возвращает поток управления на уровне JVM до тех пор,
      // пока не истечет его задержка, он фактически тратит дефицитный ресурс (базовое ядро Thread на всю свою продолжительность,
      // не давая другим действиям использовать этот ресурс более эффективно в промежутке.
      // И наоборот, schedule возвращается немедленно при запуске и просто вызывает обратный вызов
      // в будущем по истечении заданного времени.
      // Это означает, что базовое ядро Thread не тратится впустую и может быть повторно использовано для оценки другой работы в промежутке.

      // Асинхронные эффекты значительно эффективнее синхронных (когда они применимы, например, для сетевого ввода-вывода или таймеров),
      // но обычно считается, что с ними сложнее работать в реальных приложениях
      // из-за необходимости вручную управлять обратными вызовами и прослушивателями событий.
      // Волокна полностью устраняют этот недостаток благодаря встроенной поддержке асинхронных эффектов.
      // В обоих приведенных выше примерах рассматриваемый эффект — это просто значение типа IO[Unit],
      // и снаружи оба эффекта ведут себя одинаково. Таким образом, разница между return/ throw и обратным вызовом
      // полностью инкапсулируется на месте определения,
      // в то время как остальная часть потока управления вашего приложения остается полностью незаметной.
      // Это большая часть мощи волокон.

      // Важно отметить, что ничто в определении «асинхронный» не подразумевает «параллельный» или «одновременный»,
      // и не отрицает значение «последовательный» (помните: все волокна являются последовательностями эффектов).
      // «Асинхронный» просто означает «производит значения или ошибки, используя обратный вызов, а не return/ throw».
      // Это деталь реализации эффекта, управляемая волокном,
      // а не более крупный фундаментальный шаблон, вокруг которого нужно проектировать.


    }

    def chapter4 = {
      // Параллельный
      // На языке Cats Effect «конкурентный» обычно относится к двум или более действиям,
      // которые определены как независимые в своем потоке управления.
      // Это противоположность «последовательному», или, скорее, «последовательный» подразумевает,
      // что что-то не может быть «конкурентным».
      // Критически важно, что «конкурентные» вещи могут оцениваться последовательно,
      // если базовая среда выполнения решит, что это оптимально, тогда как действия,
      // которые являются последовательными, всегда будут оцениваться одно за другим.

      // Параллелизм часто путают с асинхронным выполнением из-за того,
      // что на практике реализация параллелизма часто опирается на некий механизм асинхронной оценки.
      // Но, как отмечено выше, асинхронность — это всего лишь деталь реализации,
      // которая ничего не говорит о параллельной и последовательной семантике.

      // Cats Effect имеет многочисленные механизмы для определения параллельных эффектов.
      // Один из самых простых из них — parTupled,
      // который оценивает пару независимых эффектов и выдает кортеж их результатов:

      // (callServiceA(params1), callServiceB(params2)).parTupled   // => IO[(Response, Response)]

      // Как и в случае со всей поддержкой параллелизма, parTupled это способ объявить базовой среде выполнения,
      // что два эффекта (callServiceA(params1) и callServiceB(params2)) независимы и могут быть оценены параллельно.
      // Cats Effect никогда не будет предполагать, что два эффекта могут быть оценены параллельно.

      // Весь параллелизм в Cats Effect реализован в терминах базовых примитивов,
      // которые создают и манипулируют волокнами: start и join.
      // Эти примитивы параллелизма очень похожи на одноименные операции в Thread, но, как и большинство вещей в Cats Effect,
      // они значительно быстрее и безопаснее.

      /*

        Структурированный параллелизм
        Формально говоря, структурированный параллелизм — это форма потока управления, в которой все параллельные операции должны образовывать
        закрытую иерархию. Концептуально это означает, что любая операция, которая разветвляет некоторые действия для параллельного выполнения,
        должна принудительно гарантировать, что эти действия будут выполнены, прежде чем двигаться дальше.
        Более того, результаты параллельной операции должны быть доступны только после ее завершения и только ее родителю в иерархии.
        parTupled выше приведен простой пример этого: IO[(Response, Response)] недоступен в результате,
        пока не будут завершены оба вызова служб, и эти ответы доступны только внутри результирующего кортежа.

        Cats Effect имеет большое количество структурированных инструментов параллелизма, в частности parTupled, parMapN, и parTraverse.
        Кроме того, он предлагает ряд более надежных структурированных операторов параллелизма, таких как background, Supervisor, и Dispatcher.
        Он также способствовал развитию экосистемы, в которой структурированный параллелизм является правилом, а не исключением,
        особенно с помощью фреймворков более высокого уровня, таких как Fs2.
        Однако структурированный параллелизм может быть очень ограничивающим, и Cats Effect не предотвращает неструктурированный параллелизм,
        когда он необходим.

        В частности, волокна могут быть started без того, чтобы вызывающий был вынужден ждать их завершения.
        Эта низкоуровневая гибкость необходима в некоторых случаях, но она также несколько опасна,
        поскольку может привести к «утечкам» волокон (когда волокно started и все ссылки на него за пределами среды выполнения отбрасываются).
        Обычно лучше полагаться на структурированные (но очень гибкие) инструменты, такие как background или Supervisor.

        Кроме того, Cats Effect предоставляет пару общих инструментов для моделирования общего параллельного состояния Ref и Deferred.
        Эти механизмы по своей сути неструктурированы и могут привести к бизнес-логике, которую излишне сложно отслеживать.
        Однако, как и многие мощные инструменты, они имеют свое время и место.
        Эти инструменты можно использовать для создания мощных абстракций более высокого уровня, таких как Queue, Semaphore и т. д.

        Все это означает, что Cats Effect поощряет структурированный параллелизм
        и предоставляет пользователям большое количество гибких инструментов для его достижения,
        но не препятствует неструктурированным параллельным композициям, таким как start или Ref.
       */

      // Параллельный

      /*

      Подобно асинхронному выполнению, параллелизм является деталью реализации среды выполнения.
      Когда две вещи оцениваются параллельно, это означает, что базовая среда выполнения и оборудование могут свободно планировать
      связанные вычисления одновременно на базовых процессорах.
      Эта концепция тесно связана с концепцией параллелизма, поскольку параллелизм — это то, как пользователи Cats Effect заявляют среде выполнения,
      что вещи могут выполняться параллельно.

      Более сложный пример непараллельной оценки параллельных эффектов может возникнуть,
      когда количество волокон превышает количество базовых Threads в среде выполнения.
      В целом, среда выполнения Cats Effect пытается поддерживать количество базовых потоков в соответствии с количеством физических потоков,
      предоставляемых оборудованием, в то время как количество волокон может вырасти до десятков миллионов
      (или даже больше в системах с большим объемом доступной памяти).
      Поскольку фактических потоков-носителей существует лишь небольшое количество,
      среда выполнения будет планировать некоторые из параллельных волокон на одном и том же базовом потоке-носителе,
      что означает, что эти волокна будут выполняться последовательно, а не параллельно.

      В качестве еще одной детали реализации стоит отметить, что волокна не могут «захватить» свой поток-носитель,
      даже если базовая среда выполнения имеет только один поток выполнения (например, JavaScript).
      Всякий раз, когда волокно выполняет асинхронный эффект, оно уступает свой поток следующему волокну в очереди.
      Кроме того, если волокно имело длинную серию последовательных эффектов без уступки,
      среда выполнения обнаружит ситуацию и вставит искусственный уступку, чтобы гарантировать,
      что другие ожидающие волокна получат шанс на выполнение. Это один из важных элементов справедливости.

      */

      // Эффекты

      // Эффект — это описание действия (или действий), которые будут выполнены, когда произойдет оценка.
      // Один очень распространенный вид эффекта IO:

      /*
        val printer: IO[Unit] = IO.println("Hello, World")
        val printAndRead: IO[String] = IO.print("Enter your name: ") >> IO.readLine
        def foo(str: String): IO[String] = ???
      */

      // В приведенном выше фрагменте printer и printAndRead оба являются эффектами:
      // они описывают действие (или в случае printAndRead, действия во множественном числе),
      // которое будет выполнено при их оценке. fooявляется примером функции, которая возвращает эффект.
      // В качестве сокращения такие функции часто называют «эффективными»: foo является эффективной функцией.

      // Это очень отличается от того, чтобы сказать, что foo это функция, которая выполняет эффекты, точно так же,
      // как printer эффект очень отличается от фактической печати.
      // Это наглядно проиллюстрировано, если мы напишем что-то вроде следующего:

      /*
        printer
        printer
        printer
      */

      // При оценке этого кода текст "Hello, World" будет напечатан ровно ноль раз, поскольку printer это просто описательное значение;
      // само по себе оно ничего не делает. Cats Effect — это возможность выражать эффекты как значения .

      // Примечательно, что это то, чего Future не может сделать:

      /*
      val printer: Future[Unit] = Future(println("Hello, World"))

      printer
      printer
      printer
      */

      // Это выведет "Hello, World" ровно один раз, то есть это printer не описание действия,
      // а скорее результаты этого действия (которое уже было выполнено вне нашего контроля).
      // Критически важно, val что замена def в приведенном выше примере приведет к выводу три раза,
      // что является источником ошибок и неожиданного поведения чаще, чем можно было бы ожидать при работе с Future.

      // При расширенном использовании эффекта кошек также часто используются типы эффектов,
      // которые не являются просто IO:

      /*
        import cats.Monad
        import cats.effect.std.Console
        import cats.syntax.all._

        def example[F[_]: Monad: Console](str: String): F[String] = {
          val printer: F[Unit] = Console[F].println(str)
          (printer >> printer).as(str)
      }
      */

      // В приведенном выше примере это эффективная функция, а printer - это эффект, как и printer >> printer и (printer >> printer).as(str).
      // Тип эффекта здесь - F, который может быть IO, но также может быть и чем-то более интересным!
      // Вызывающий объект example может свободно выбирать эффект на месте вызова, например, написав что-то вроде
      // example[IO]("Привет, Мир"), что, в свою очередь, вернет значение IO[String].
      // Большая часть композиционных возможностей экосистем Cats достигается с помощью этой техники на поверхности.

      // Побочные эффекты
      // Когда выполнение фрагмента кода вызывает изменения, выходящие за рамки простого возврата значения,
      // мы обычно говорим, что код «имеет побочные эффекты». Более интуитивно понятно, что код, в котором вам важно,
      // будет ли он запущен больше одного раза и/или когда он будет запущен, почти всегда имеет побочные эффекты.
      // Классический пример этого System.out.println:

      /*
           def double(x: Int): Int = {
              System.out.println("Hello, World")
              x + x
           }
      */

      // Функция double принимает Int и возвращает то же самое, что и Int добавленное к себе... и печатает "Hello, World" на стандартный вывод.
      // Это то, что подразумевается под "side" в "side-effect": что-то еще делается "на стороне".
      // То же самое можно сказать о регистрации, изменении значения a var, выполнении сетевого вызова и т. д. и т. п.

      // Важно, что побочный эффект — это не то же самое, что и эффект.
      // Эффект — это описание некоторого действия, где действие может вызывать побочные эффекты при выполнении.
      // Тот факт, что эффекты — это всего лишь описания действий, делает их гораздо более безопасными и контролируемыми.
      // Когда фрагмент кода содержит побочный эффект, это действие просто происходит.
      // Вы не можете заставить его вычисляться параллельно, или в другом пуле потоков, или по расписанию,
      // или заставить его повторить попытку в случае сбоя.

      // Поскольку эффект — это всего лишь описание того, какие действия следует предпринять,
      // вы можете свободно изменять семантику того, как он в конечном итоге выполняется,
      // чтобы удовлетворить потребности вашего конкретного варианта использования.

      // В Cats Effect код, содержащий побочные эффекты, всегда должен быть заключен в один из "специальных" конструкторов.
      // В частности:

      /*
          Синхронный ( return или throw)
            IO(...) или IO.delay(...)
            IO.blocking(...)
            IO.interruptible(...)
            IO.interruptibleMany(...)

          Асинхронный (вызывает обратный вызов)
            IO.asyncилиIO.async_
       */

      // Когда код, вызывающий побочные эффекты, заключен в один из этих конструкторов, сам код по-прежнему содержит побочные эффекты,
      // но за пределами лексической области действия конструктора мы можем рассуждать обо всем этом (например, включая IO(...))
      // как об эффекте, а не как о побочном эффекте.

      // Например, мы можем обернуть System.out.println код побочного эффекта, приведенный ранее, чтобы преобразовать его в значение эффекта:

      /*
            val wrapped: IO[Unit] = IO(System.out.println("Hello, World"))
      */

      // Строгое соблюдение этого правила и постоянное оборачивание логики побочных эффектов в конструкторы эффектов
      // раскрывает всю мощь и компоновку функционального программирования.
      // Это также позволяет Cats Effect более эффективно планировать и оптимизировать ваше приложение,
      // поскольку он может делать более агрессивные предположения о том, когда оценивать фрагменты кода,
      // чтобы лучше использовать ресурсы ЦП и кэша.

    }
  }

  //part1.chapter1
  //part1.chapter2
  part1.chapter3
  part1.chapter4

}

object Main2 extends IOApp.Simple {
  val run = IO.println("Hello") >> IO.println("World")
}